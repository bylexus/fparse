{"version":3,"file":"fparser.umd.cjs","sources":["../src/helpers.ts","../src/math_function_helper.ts","../src/math_operator_helper.ts","../src/expression.ts","../src/tokenizer.ts","../src/parser.ts","../src/fparser.ts"],"sourcesContent":["\n/**\n * accesses an object's property by evaluating the given path.\n *\n * Example:\n *  - Object: { a: { b: { c: 1 } } }\n *  - Path: ['a', 'b', 'c']\n *  - Result: 1\n *\n * @param object\n * @param path\n * @param fullPath\n * @returns\n */\nexport function getProperty(object: ValueObject, path: string[], fullPath: string) {\n    let curr: (number | string | Function | Object) & { [key: string]: any } = object;\n    let prev: ((number | string | Function | Object) & { [key: string]: any }) | null = null;\n    for (let propName of path) {\n        if (!['object', 'string'].includes(typeof curr)) {\n            throw new Error(`Cannot evaluate ${propName}, property not found (from path ${fullPath})`);\n        }\n        if (typeof curr === 'object' && !(propName in curr)) {\n            throw new Error(`Cannot evaluate ${propName}, property not found (from path ${fullPath})`);\n        }\n        if (typeof curr === 'string' && !curr.hasOwnProperty(propName)) {\n            throw new Error(`Cannot evaluate ${propName}, property not found (from path ${fullPath})`);\n        }\n        prev = curr;\n        curr = curr[propName];\n    }\n\n    // If we have a function that is part of an object (e.g. array.includes()), we need to\n    // bind the scope before returning:\n    if (typeof curr === 'function' && prev) {\n        curr = curr.bind(prev);\n    }\n\n    return curr;\n}","\nexport class MathFunctionHelper {\n    static throwIfNotNumber(value: number | string) {\n        const valueType = typeof value;\n        if (valueType === 'string') {\n            throw new Error('Strings are not allowed in math operations');\n        }\n    }\n}\n","export class MathOperatorHelper {\n    static throwIfNotNumber(value: number | string) {\n        const valueType = typeof value;\n        if (valueType === 'string') {\n            throw new Error('Strings are not allowed in math operations');\n        }\n    }\n}\n","import Formula from \"./fparser\";\nimport { getProperty } from \"./helpers\";\nimport { MathFunctionHelper } from \"./math_function_helper\";\nimport { MathOperatorHelper } from \"./math_operator_helper\";\nimport type { Token } from \"./tokenizer\";\n\n/**\n * Base class for all expressions: An Expression is somethint that eventually evaluates to a\n * final value, like a number, or a string. It can be composed of other expressions, which\n * are evaluated recursively until a final value is reached.\n */\nexport abstract class Expression {\n    /**\n     * Creates an operator expression from a token.\n     * @param operatorToken The operator token (or string for backward compatibility)\n     * @param left Left operand expression\n     * @param right Right operand expression\n     */\n    static createOperatorExpression(\n        operatorToken: Token | string,\n        left: Expression,\n        right: Expression\n    ) {\n        // Extract operator string from token or use directly if it's a string (backward compatibility)\n        const operator = typeof operatorToken === 'string' ? operatorToken : String(operatorToken.value);\n\n        if (operator === '^') {\n            return new PowerExpression(left, right);\n        }\n        if (['*', '/'].includes(operator)) {\n            return new MultDivExpression(operator, left, right);\n        }\n        if (['+', '-'].includes(operator)) {\n            return new PlusMinusExpression(operator, left, right);\n        }\n        if (['<', '>', '<=', '>=', '=', '!='].includes(operator)) {\n            return new LogicalExpression(operator, left, right);\n        }\n        throw new Error(`Unknown operator: ${operator}`);\n    }\n\n    abstract evaluate(params: ValueObject): any;\n\n    toString() {\n        return '';\n    }\n}\n\n/**\n * An unused expression - it is only used during parsing stage, to store a placeholder for a\n * real expression later.\n */\nexport class PlaceholderExpression extends Expression {\n    evaluate(params: ValueObject): number | string {\n        throw new Error('PlaceholderExpression cannot be evaluated');\n    }\n    toString() {\n        return '[placeholder]';\n    }\n}\n\n/**\n * Represents a bracketed expression: (expr)\n * It evaluates its inner expression.\n */\nexport class BracketExpression extends Expression {\n    innerExpression: Expression;\n\n    constructor(expr: Expression) {\n        super();\n        this.innerExpression = expr;\n        if (!(this.innerExpression instanceof Expression)) {\n            throw new Error('No inner expression given for bracket expression');\n        }\n    }\n    evaluate(params = {}): number | string {\n        return this.innerExpression.evaluate(params);\n    }\n    toString() {\n        return `(${this.innerExpression.toString()})`;\n    }\n}\n\n/**\n * Represents a final value, e.g. a number.\n */\nexport class ValueExpression extends Expression {\n    value: number | string;\n    type: string;\n\n    constructor(value: number | string, type: string = 'number') {\n        super();\n        this.value = Number(value);\n        switch (type) {\n            case 'number':\n                this.value = Number(value);\n                if (isNaN(this.value)) {\n                    throw new Error('Cannot parse number: ' + value);\n                }\n                break;\n            case 'string':\n                this.value = String(value);\n                break;\n            default:\n                throw new Error('Invalid value type: ' + type);\n        }\n        this.type = type;\n    }\n    evaluate(): number | string {\n        return this.value;\n    }\n    toString() {\n        switch (this.type) {\n            case 'number':\n                return String(this.value);\n            case 'string':\n                return String('\"' + this.value + '\"');\n            default:\n                throw new Error('Invalid type');\n        }\n    }\n}\n\n/**\n * Represents the '+' or '-' operator expression:\n * it evaluates its left and right expression and returns the sum / difference of the result\n */\nexport class PlusMinusExpression extends Expression {\n    static PLUS = '+';\n    static MINUS = '-';\n\n    operator: string;\n    left: Expression;\n    right: Expression;\n\n    constructor(operator: string, left: Expression, right: Expression) {\n        super();\n        if (!['+', '-'].includes(operator)) {\n            throw new Error(`Operator not allowed in Plus/Minus expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const leftValue = this.left.evaluate(params);\n        const rightValue = this.right.evaluate(params);\n        MathOperatorHelper.throwIfNotNumber(leftValue);\n        MathOperatorHelper.throwIfNotNumber(rightValue);\n        if (this.operator === '+') {\n            return Number(leftValue) + Number(rightValue);\n        }\n        if (this.operator === '-') {\n            return Number(leftValue) - Number(rightValue);\n        }\n        throw new Error('Unknown operator for PlusMinus expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\n/**\n * Represents the '*' or '/' operator expression:\n * it evaluates its left and right expression and returns the product / division of the two.\n */\nexport class MultDivExpression extends Expression {\n    static MULT = '*';\n    static DIV = '/';\n\n    operator: string;\n    left: Expression;\n    right: Expression;\n\n    constructor(operator: string, left: Expression, right: Expression) {\n        super();\n        if (!['*', '/'].includes(operator)) {\n            throw new Error(`Operator not allowed in Multiply/Division expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const leftValue = this.left.evaluate(params);\n        const rightValue = this.right.evaluate(params);\n        MathOperatorHelper.throwIfNotNumber(leftValue);\n        MathOperatorHelper.throwIfNotNumber(rightValue);\n        if (this.operator === '*') {\n            return Number(leftValue) * Number(rightValue);\n        }\n        if (this.operator === '/') {\n            return Number(leftValue) / Number(rightValue);\n        }\n        throw new Error('Unknown operator for MultDiv expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\n/**\n * Represents the 'power of' operator expression:\n * evaluates base^exponent.\n */\nexport class PowerExpression extends Expression {\n    base: Expression;\n    exponent: Expression;\n\n    constructor(base: Expression, exponent: Expression) {\n        super();\n        this.base = base;\n        this.exponent = exponent;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const baseValue = this.base.evaluate(params);\n        const exponentValue = this.exponent.evaluate(params);\n        MathOperatorHelper.throwIfNotNumber(baseValue);\n        MathOperatorHelper.throwIfNotNumber(exponentValue);\n\n        return Math.pow(Number(baseValue), Number(exponentValue));\n    }\n\n    toString() {\n        return `${this.base.toString()}^${this.exponent.toString()}`;\n    }\n}\n\n/**\n * Represents locical operator expressions: All logical operations\n * evaluate either to 0 or 1 (false or true): this way, you can use them in calculations\n * to enable / disable different parts of the formula.\n */\nexport class LogicalExpression extends Expression {\n    static LT = '<';\n    static GT = '>';\n    static LTE = '<=';\n    static GTE = '>=';\n    static EQ = '=';\n    static NEQ = '!=';\n\n    operator: string;\n    left: Expression;\n    right: Expression;\n\n    constructor(operator: string, left: Expression, right: Expression) {\n        super();\n        if (!['<', '>', '<=', '>=', '=', '!='].includes(operator)) {\n            throw new Error(`Operator not allowed in Logical expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const leftValue = this.left.evaluate(params);\n        const rightValue = this.right.evaluate(params);\n        switch (this.operator) {\n            case '<':\n                return leftValue < rightValue ? 1 : 0;\n            case '>':\n                return leftValue > rightValue ? 1 : 0;\n            case '<=':\n                return leftValue <= rightValue ? 1 : 0;\n            case '>=':\n                return leftValue >= rightValue ? 1 : 0;\n            case '=':\n                return leftValue === rightValue ? 1 : 0;\n            case '!=':\n                return leftValue !== rightValue ? 1 : 0;\n        }\n        throw new Error('Unknown operator for Logical expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\n/**\n * Represents a function expression: evaluates the expression in the function arguments,\n * then executes the function with the evaluated arguments, an evaluates the result.\n */\nexport class FunctionExpression extends Expression {\n    fn: string;\n    varPath: string[];\n    argumentExpressions: Expression[];\n    formulaObject: Formula | null;\n    blacklisted: boolean | undefined;\n\n    constructor(fn: string | null, argumentExpressions: Expression[], formulaObject: Formula | null = null) {\n        super();\n        this.fn = fn ?? '';\n        this.varPath = this.fn.split('.');\n        this.argumentExpressions = argumentExpressions || [];\n        this.formulaObject = formulaObject;\n        this.blacklisted = undefined;\n    }\n\n    evaluate(params: ValueObject = {}): number | string {\n        params = params || {};\n        const paramValues = this.argumentExpressions.map((a) => a.evaluate(params));\n\n        // If the params object itself has a function definition with\n        // the function name, call this one:\n        // let fn = params[this.fn];\n        try {\n            let fn = getProperty(params, this.varPath, this.fn);\n            if (fn instanceof Function) {\n                return fn.apply(this, paramValues);\n            }\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n\n        let objFn;\n        try {\n            // perhaps the Formula object has the function? so call it:\n            objFn = getProperty(this.formulaObject ?? {}, this.varPath, this.fn);\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        if (this.formulaObject && objFn instanceof Function) {\n            // Don't, if it is blacklisted:\n            if (this.isBlacklisted()) {\n                throw new Error('Blacklisted function called: ' + this.fn);\n            }\n            return objFn.apply(this.formulaObject, paramValues);\n        }\n\n        try {\n            // Has the JS Math object a function as requested? Call it:\n            const mathFn = getProperty(Math, this.varPath, this.fn);\n            if (mathFn instanceof Function) {\n                paramValues.forEach((paramValue) => {\n                    MathFunctionHelper.throwIfNotNumber(paramValue);\n                });\n\n                return mathFn.apply(this, paramValues);\n            }\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        // No more options left: sorry!\n        throw new Error('Function not found: ' + this.fn);\n    }\n\n    toString() {\n        return `${this.fn}(${this.argumentExpressions.map((a) => a.toString()).join(', ')})`;\n    }\n\n    isBlacklisted() {\n        // cache evaluation of blacklisted function, to save call time:\n        if (this.blacklisted === undefined) {\n            this.blacklisted = Formula.functionBlacklist.includes(\n                this.formulaObject ? this.formulaObject[this.fn] : null\n            );\n        }\n        return this.blacklisted;\n    }\n}\n\nexport class VariableExpression extends Expression {\n    fullPath: string;\n    varPath: string[];\n    formulaObject: Formula | null;\n\n    constructor(fullPath: string, formulaObj: Formula | null = null) {\n        super();\n        this.formulaObject = formulaObj;\n        this.fullPath = fullPath;\n        this.varPath = fullPath.split('.');\n    }\n\n    evaluate(params = {}): any {\n        // params contain variable / value pairs: If this object's variable matches\n        // a varname found in the params, return the value.\n        // eg: params = {x: 5,y:3}, varname = x, return 5\n        // Objects and arrays are also supported:\n        // e.g. params = {x: {y: 5}}, varname = x.y, return 5\n        //  or  params = {x: [2,4,6]}, varname = x.2, return 6\n        // Objects can also be passed as function arguments:\n        // e.g. params = {p1: {x: 1, y: 2}}, varname = p1, return {x: 1, y: 2}\n\n        // Let's look in the value object first:\n        let value = undefined;\n        try {\n            value = getProperty(params, this.varPath, this.fullPath);\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        if (value === undefined) {\n            // Now have a look at the formula object:\n            // This will throw an error if the property is not found:\n            value = getProperty(this.formulaObject ?? {}, this.varPath, this.fullPath);\n        }\n        if (typeof value === 'function') {\n            throw new Error(`Cannot use ${this.fullPath} as value: It is a function and not allowed as a variable value.`);\n        }\n\n        return value;\n    }\n    toString() {\n        return `${this.varPath.join('.')}`;\n    }\n}","/**\n * Tokenizer for Formula Parser\n * Converts a formula string into a stream of tokens\n */\n\nexport enum TokenType {\n    NUMBER = 'NUMBER',\n    VARIABLE = 'VARIABLE',\n    OPERATOR = 'OPERATOR',\n    LOGICAL_OPERATOR = 'LOGICAL_OPERATOR',\n    FUNCTION = 'FUNCTION',\n    LEFT_PAREN = 'LEFT_PAREN',\n    RIGHT_PAREN = 'RIGHT_PAREN',\n    COMMA = 'COMMA',\n    STRING = 'STRING',\n    EOF = 'EOF'\n}\n\nexport interface Token {\n    type: TokenType;\n    value: string | number;\n    raw: string;           // original text from input\n    position: number;      // character position in input\n    length: number;        // length of the token in original input\n}\n\nexport class Tokenizer {\n    private input: string;\n    private position: number;\n\n    // Regex patterns for token matching\n    private static readonly PATTERNS = {\n        WHITESPACE: /^\\s+/,\n        NUMBER: /^-?\\d+(\\.\\d+)?([eE][+\\-]?\\d+)?/,\n        IDENTIFIER: /^[a-zA-Z_][a-zA-Z0-9_.]*/,\n        BRACKETED_IDENTIFIER: /^\\[([^\\]]*)\\]/,  // Match anything between brackets, validate later\n        STRING_DOUBLE: /^\"((?:[^\"\\\\]|\\\\.)*)\"/,\n        STRING_SINGLE: /^'((?:[^'\\\\]|\\\\.)*)'/,\n        LOGICAL_OPERATOR: /^(<=|>=|!=|<|>|=)/,\n        OPERATOR: /^[+\\-*/^]/,\n        LEFT_PAREN: /^\\(/,\n        RIGHT_PAREN: /^\\)/,\n        COMMA: /^,/\n    };\n\n    constructor() {\n        this.input = '';\n        this.position = 0;\n    }\n\n    tokenize(input: string): Token[] {\n        this.input = input;\n        this.position = 0;\n        const tokens: Token[] = [];\n\n        while (this.position < this.input.length) {\n            this.skipWhitespace();\n\n            if (this.position >= this.input.length) break;\n\n            const token = this.nextToken(tokens);\n            if (token) {\n                tokens.push(token);\n            }\n        }\n\n        tokens.push({\n            type: TokenType.EOF,\n            value: '',\n            raw: '',\n            position: this.position,\n            length: 0\n        });\n        return tokens;\n    }\n\n    private nextToken(tokens: Token[]): Token | null {\n        // Try each token pattern in order\n        // String must be checked first to avoid conflicts\n        return (\n            this.readString() ||\n            this.readLogicalOperator() ||\n            this.readNumber(tokens) ||\n            this.readOperator() ||\n            this.readParenthesis() ||\n            this.readComma() ||\n            this.readIdentifier() ||\n            this.throwUnexpectedChar()\n        );\n    }\n\n    private skipWhitespace(): void {\n        const remaining = this.input.slice(this.position);\n        const match = remaining.match(Tokenizer.PATTERNS.WHITESPACE);\n        if (match) {\n            this.position += match[0].length;\n        }\n    }\n\n    private remaining(): string {\n        return this.input.slice(this.position);\n    }\n\n    /**\n     * Read a number token. Includes the minus sign if it's unambiguously part of the number.\n     * Handles negative numbers when preceded by operators, commas, left parenthesis, or at start.\n     * Supports scientific notation (e.g., 1.23e5, 1.23E+5, 1.23e-5).\n     */\n    private readNumber(tokens: Token[]): Token | null {\n        const start = this.position;\n        const remaining = this.remaining();\n\n        // Try to match a number (with optional negative sign)\n        const match = remaining.match(Tokenizer.PATTERNS.NUMBER);\n        if (!match) {\n            return null;\n        }\n\n        const raw = match[0];\n\n        // If the number starts with '-', check if it's actually a negative number\n        // or if the '-' should be treated as a separate operator\n        if (raw.startsWith('-')) {\n            const prevToken = tokens.length > 0 ? tokens[tokens.length - 1] : null;\n            const canBeNegative =\n                !prevToken ||\n                prevToken.type === TokenType.OPERATOR ||\n                prevToken.type === TokenType.LOGICAL_OPERATOR ||\n                prevToken.type === TokenType.COMMA ||\n                prevToken.type === TokenType.LEFT_PAREN;\n\n            if (!canBeNegative) {\n                // The '-' is an operator, not part of the number\n                return null;\n            }\n        }\n\n        this.position += raw.length;\n        const value = parseFloat(raw);\n\n        return {\n            type: TokenType.NUMBER,\n            value: value,\n            raw: raw,\n            position: start,\n            length: raw.length\n        };\n    }\n\n    /**\n     * Read an identifier (variable or function name).\n     * Supports: myVar, x, PI, my_var, obj.prop, [myVar], [obj.prop]\n     */\n    private readIdentifier(): Token | null {\n        const start = this.position;\n        const remaining = this.remaining();\n\n        // Try bracketed identifier first: [varname]\n        let match = remaining.match(Tokenizer.PATTERNS.BRACKETED_IDENTIFIER);\n        if (match) {\n            const raw = match[0];\n            const value = match[1]; // captured group without brackets\n\n            if (value === '') {\n                throw new Error(`Empty bracketed variable at position ${start}`);\n            }\n\n            // Validate that the content only contains valid identifier characters\n            if (!/^[a-zA-Z0-9_.]+$/.test(value)) {\n                // Find the first invalid character\n                const invalidCharMatch = value.match(/[^a-zA-Z0-9_.]/);\n                const invalidChar = invalidCharMatch ? invalidCharMatch[0] : value[0];\n                const invalidCharPos = start + 1 + value.indexOf(invalidChar);\n                throw new Error(\n                    `Invalid character '${invalidChar}' in bracketed variable at position ${invalidCharPos}`\n                );\n            }\n\n            this.position += raw.length;\n\n            // Look ahead to determine if this is a function call\n            const savedPos = this.position;\n            this.skipWhitespace();\n            const isFunction = this.position < this.input.length && this.input[this.position] === '(';\n            this.position = savedPos; // restore position\n\n            return {\n                type: isFunction ? TokenType.FUNCTION : TokenType.VARIABLE,\n                value: value,\n                raw: raw,\n                position: start,\n                length: raw.length\n            };\n        }\n\n        // Try regular identifier: myVar, x, PI\n        match = remaining.match(Tokenizer.PATTERNS.IDENTIFIER);\n        if (match) {\n            const raw = match[0];\n            const value = raw;\n            this.position += raw.length;\n\n            // Look ahead to determine if this is a function call\n            const savedPos = this.position;\n            this.skipWhitespace();\n            const isFunction = this.position < this.input.length && this.input[this.position] === '(';\n            this.position = savedPos; // restore position\n\n            return {\n                type: isFunction ? TokenType.FUNCTION : TokenType.VARIABLE,\n                value: value,\n                raw: raw,\n                position: start,\n                length: raw.length\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * Read a string literal (single or double quoted).\n     * Supports escaped quotes: \\\" or \\'\n     */\n    private readString(): Token | null {\n        const start = this.position;\n        const remaining = this.remaining();\n\n        // Try double-quoted string\n        let match = remaining.match(Tokenizer.PATTERNS.STRING_DOUBLE);\n        if (match) {\n            const raw = match[0];\n            const capturedValue = match[1]; // content between quotes\n            // Process escape sequences: \\\\ -> \\, \\\" -> \"\n            const value = capturedValue.replace(/\\\\(.)/g, '$1');\n            this.position += raw.length;\n\n            return {\n                type: TokenType.STRING,\n                value: value,\n                raw: raw,\n                position: start,\n                length: raw.length\n            };\n        }\n\n        // Try single-quoted string\n        match = remaining.match(Tokenizer.PATTERNS.STRING_SINGLE);\n        if (match) {\n            const raw = match[0];\n            const capturedValue = match[1]; // content between quotes\n            // Process escape sequences: \\\\ -> \\, \\' -> '\n            const value = capturedValue.replace(/\\\\(.)/g, '$1');\n            this.position += raw.length;\n\n            return {\n                type: TokenType.STRING,\n                value: value,\n                raw: raw,\n                position: start,\n                length: raw.length\n            };\n        }\n\n        // Check for unterminated string\n        if (remaining.startsWith('\"') || remaining.startsWith(\"'\")) {\n            throw new Error(`Unterminated string at position ${start}`);\n        }\n\n        return null;\n    }\n\n    /**\n     * Read a simple operator: +, -, *, /, ^\n     */\n    private readOperator(): Token | null {\n        const start = this.position;\n        const remaining = this.remaining();\n\n        const match = remaining.match(Tokenizer.PATTERNS.OPERATOR);\n        if (!match) {\n            return null;\n        }\n\n        const raw = match[0];\n        this.position += raw.length;\n\n        return {\n            type: TokenType.OPERATOR,\n            value: raw,\n            raw: raw,\n            position: start,\n            length: raw.length\n        };\n    }\n\n    /**\n     * Read a logical operator: <, >, <=, >=, =, !=\n     */\n    private readLogicalOperator(): Token | null {\n        const start = this.position;\n        const remaining = this.remaining();\n\n        // Check for invalid '!' operator\n        if (remaining.startsWith('!') && !remaining.startsWith('!=')) {\n            throw new Error(`Invalid operator '!' at position ${start}. Did you mean '!='?`);\n        }\n\n        const match = remaining.match(Tokenizer.PATTERNS.LOGICAL_OPERATOR);\n        if (!match) {\n            return null;\n        }\n\n        const raw = match[0];\n        this.position += raw.length;\n\n        return {\n            type: TokenType.LOGICAL_OPERATOR,\n            value: raw,\n            raw: raw,\n            position: start,\n            length: raw.length\n        };\n    }\n\n    /**\n     * Read parentheses\n     */\n    private readParenthesis(): Token | null {\n        const start = this.position;\n        const remaining = this.remaining();\n\n        // Try left parenthesis\n        let match = remaining.match(Tokenizer.PATTERNS.LEFT_PAREN);\n        if (match) {\n            const raw = match[0];\n            this.position += raw.length;\n            return {\n                type: TokenType.LEFT_PAREN,\n                value: raw,\n                raw: raw,\n                position: start,\n                length: raw.length\n            };\n        }\n\n        // Try right parenthesis\n        match = remaining.match(Tokenizer.PATTERNS.RIGHT_PAREN);\n        if (match) {\n            const raw = match[0];\n            this.position += raw.length;\n            return {\n                type: TokenType.RIGHT_PAREN,\n                value: raw,\n                raw: raw,\n                position: start,\n                length: raw.length\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * Read comma separator\n     */\n    private readComma(): Token | null {\n        const start = this.position;\n        const remaining = this.remaining();\n\n        const match = remaining.match(Tokenizer.PATTERNS.COMMA);\n        if (!match) {\n            return null;\n        }\n\n        const raw = match[0];\n        this.position += raw.length;\n\n        return {\n            type: TokenType.COMMA,\n            value: raw,\n            raw: raw,\n            position: start,\n            length: raw.length\n        };\n    }\n\n    /**\n     * Throw an error for unexpected characters\n     */\n    private throwUnexpectedChar(): never {\n        const char = this.input[this.position] || 'EOF';\n        throw new Error(`Unexpected character '${char}' at position ${this.position}`);\n    }\n}\n","/**\n * Parser for Formula Parser\n * Converts a stream of tokens into an Abstract Syntax Tree (AST)\n * Uses Pratt parsing algorithm for operator precedence\n */\n\nimport { Token, TokenType } from './tokenizer';\nimport {\n    Expression,\n    BracketExpression,\n    ValueExpression,\n    VariableExpression,\n    FunctionExpression,\n    MultDivExpression\n} from './expression';\nimport Formula from './fparser';\n\n/**\n * Operator precedence levels (higher = tighter binding)\n */\nconst PRECEDENCE = {\n    // Logical operators (lowest precedence)\n    '=': 1,\n    '!=': 1,\n    '<': 1,\n    '>': 1,\n    '<=': 1,\n    '>=': 1,\n\n    // Addition/Subtraction\n    '+': 2,\n    '-': 2,\n\n    // Multiplication/Division\n    '*': 3,\n    '/': 3,\n\n    // Power (highest precedence, right-associative)\n    '^': 4\n};\n\n/**\n * Parser class that builds an AST from tokens\n */\nexport class Parser {\n    private tokens: Token[];\n    private current: number;\n    private formulaObject: Formula;\n\n    constructor(tokens: Token[], formulaObject: Formula) {\n        this.tokens = tokens;\n        this.current = 0;\n        this.formulaObject = formulaObject;\n    }\n\n    /**\n     * Main entry point: Parse the token stream into an Expression tree\n     */\n    parse(): Expression {\n        const expr = this.parseExpression(0);\n        if (!this.isAtEnd()) {\n            const token = this.peek();\n            throw new Error(\n                `Unexpected token '${token.value}' at position ${token.position}: Expected end of expression`\n            );\n        }\n        return expr;\n    }\n\n    /**\n     * Pratt parsing: handles operator precedence elegantly\n     * @param minPrecedence Minimum precedence level to parse\n     */\n    private parseExpression(minPrecedence: number): Expression {\n        let left = this.parsePrimary();\n\n        while (!this.isAtEnd()) {\n            const token = this.peek();\n\n            // Stop if we hit a non-operator token (parenthesis, comma, etc.)\n            if (token.type !== TokenType.OPERATOR && token.type !== TokenType.LOGICAL_OPERATOR) {\n                break;\n            }\n\n            const precedence = this.getPrecedence(token);\n\n            if (precedence < minPrecedence) break;\n\n            // Handle right-associative operators (power)\n            const isRightAssociative = token.value === '^';\n            const nextPrecedence = isRightAssociative ? precedence : precedence + 1;\n\n            this.consume();\n            const right = this.parseExpression(nextPrecedence);\n\n            left = Expression.createOperatorExpression(\n                token,\n                left,\n                right\n            );\n        }\n\n        return left;\n    }\n\n    /**\n     * Parse primary expressions: numbers, variables, functions, parentheses, unary operators\n     */\n    private parsePrimary(): Expression {\n        const token = this.peek();\n\n        // Handle unary minus: convert to -1 * expr\n        if (this.match(TokenType.OPERATOR) && token.value === '-') {\n            this.consume();\n            const expr = this.parsePrimary();\n            return new MultDivExpression('*', new ValueExpression(-1), expr);\n        }\n\n        // Handle unary plus: just skip it\n        if (this.match(TokenType.OPERATOR) && token.value === '+') {\n            this.consume();\n            return this.parsePrimary();\n        }\n\n        // Numbers\n        if (this.match(TokenType.NUMBER)) {\n            this.consume();\n            return new ValueExpression(token.value);\n        }\n\n        // Strings\n        if (this.match(TokenType.STRING)) {\n            this.consume();\n            return new ValueExpression(token.value, 'string');\n        }\n\n        // Parenthesized expressions\n        if (this.match(TokenType.LEFT_PAREN)) {\n            return this.parseParenthesizedExpression();\n        }\n\n        // Variables or Functions\n        if (this.match(TokenType.VARIABLE, TokenType.FUNCTION)) {\n            return this.parseVariableOrFunction();\n        }\n\n        throw new Error(\n            `Unexpected token '${token.value}' at position ${token.position}: Expected number, variable, function, or '('`\n        );\n    }\n\n    /**\n     * Parse a parenthesized expression: (expr)\n     */\n    private parseParenthesizedExpression(): Expression {\n        const leftParen = this.consume(TokenType.LEFT_PAREN);\n        const expr = this.parseExpression(0);\n\n        if (!this.match(TokenType.RIGHT_PAREN)) {\n            const token = this.peek();\n            throw new Error(\n                `Missing closing parenthesis at position ${token.position}: Expected ')' to match '(' at position ${leftParen.position}`\n            );\n        }\n\n        this.consume(TokenType.RIGHT_PAREN);\n        return new BracketExpression(expr);\n    }\n\n    /**\n     * Parse a variable or function call\n     */\n    private parseVariableOrFunction(): Expression {\n        const token = this.consume();\n        const name = token.value as string;\n\n        // Check if it's a function call (next token is '(')\n        if (this.match(TokenType.LEFT_PAREN)) {\n            return this.parseFunctionCall(name, token.position);\n        }\n\n        // It's a variable\n        this.formulaObject.registerVariable(name);\n        return new VariableExpression(name, this.formulaObject);\n    }\n\n    /**\n     * Parse a function call: functionName(arg1, arg2, ...)\n     */\n    private parseFunctionCall(name: string, namePosition: number): Expression {\n        const leftParen = this.consume(TokenType.LEFT_PAREN);\n        const args: Expression[] = [];\n\n        // Parse arguments (if any)\n        if (!this.match(TokenType.RIGHT_PAREN)) {\n            do {\n                args.push(this.parseExpression(0));\n            } while (this.matchAndConsume(TokenType.COMMA));\n        }\n\n        if (!this.match(TokenType.RIGHT_PAREN)) {\n            const token = this.peek();\n            throw new Error(\n                `Missing closing parenthesis for function '${name}' at position ${token.position}: Expected ')' to match '(' at position ${leftParen.position}`\n            );\n        }\n\n        this.consume(TokenType.RIGHT_PAREN);\n        return new FunctionExpression(name, args, this.formulaObject);\n    }\n\n    // ==================== Helper Methods ====================\n\n    /**\n     * Get the current token without consuming it\n     */\n    private peek(): Token {\n        return this.tokens[this.current];\n    }\n\n    /**\n     * Consume the current token and move to the next one\n     * @param expected Optional: throw error if current token is not of this type\n     */\n    private consume(expected?: TokenType): Token {\n        const token = this.peek();\n        if (expected && token.type !== expected) {\n            throw new Error(\n                `Expected ${expected} at position ${token.position}, got ${token.type} ('${token.value}')`\n            );\n        }\n        this.current++;\n        return token;\n    }\n\n    /**\n     * Check if the current token matches any of the given types\n     */\n    private match(...types: TokenType[]): boolean {\n        return types.includes(this.peek().type);\n    }\n\n    /**\n     * If the current token matches the given type, consume it and return true\n     */\n    private matchAndConsume(type: TokenType): boolean {\n        if (this.match(type)) {\n            this.consume();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Check if we've reached the end of the token stream\n     */\n    private isAtEnd(): boolean {\n        return this.peek().type === TokenType.EOF;\n    }\n\n    /**\n     * Get the precedence level for a token\n     */\n    private getPrecedence(token: Token): number {\n        if (token.type === TokenType.LOGICAL_OPERATOR) {\n            const op = token.value as string;\n            return PRECEDENCE[op as keyof typeof PRECEDENCE] ?? 0;\n        }\n        if (token.type === TokenType.OPERATOR) {\n            const op = token.value as string;\n            return PRECEDENCE[op as keyof typeof PRECEDENCE] ?? 0;\n        }\n        return 0;\n    }\n}\n","import {\n    BracketExpression,\n    Expression,\n    FunctionExpression,\n    LogicalExpression,\n    MultDivExpression,\n    PlusMinusExpression,\n    PowerExpression,\n    ValueExpression,\n    VariableExpression\n} from './expression';\n\nimport { Tokenizer, TokenType } from './tokenizer';\nimport { Parser } from './parser';\n\n/**\n * JS Formula Parser\n * -------------------\n * (c) 2012-2024 Alexander Schenkel, alex@alexi.ch\n *\n * JS Formula Parser takes a string, parses its mathmatical formula\n * and creates an evaluatable Formula object of it.\n *\n * Example input:\n *\n * var fObj = new Formula('sin(PI*x)/(2*PI)');\n * var result = fObj.evaluate({x: 2});\n * var results = fObj.evaluate([\n *     {x: 2},\n *     {x: 4},\n *     {x: 8}\n * ]);\n *\n * LICENSE:\n * -------------\n * MIT license, see LICENSE file\n */\nconst MATH_CONSTANTS = {\n    PI: Math.PI,\n    E: Math.E,\n    LN2: Math.LN2,\n    LN10: Math.LN10,\n    LOG2E: Math.LOG2E,\n    LOG10E: Math.LOG10E,\n    SQRT1_2: Math.SQRT1_2,\n    SQRT2: Math.SQRT2\n};\n\ndeclare global {\n    interface Math {\n        [key: string]: number | Function;\n    }\n}\n\n/**\n * Evaluates a variable within a formula to its value. The variable value\n * is expected to be given in the evaluate() method or on the formula object.\n */\n\n/**\n * The Formula class represents a mathematical formula, including functions to evaluate\n * the formula to its final result.\n *\n * Usage example:\n *\n * 1. Create a Formula object instance by passing a formula string:\n * const fObj = new Formula('2^x');\n *\n * 2. evaluate the formula, delivering a value object for each unknown entity:\n * let result = fObj.evaluate({ x: 3 }); // result = 8\n */\nexport default class Formula {\n    [key: string]: any;\n    static Expression = Expression;\n    static BracketExpression = BracketExpression;\n    static PowerExpression = PowerExpression;\n    static MultDivExpression = MultDivExpression;\n    static PlusMinusExpression = PlusMinusExpression;\n    static LogicalExpression = LogicalExpression;\n    static ValueExpression = ValueExpression;\n    static VariableExpression = VariableExpression;\n    static FunctionExpression = FunctionExpression;\n    static MATH_CONSTANTS = MATH_CONSTANTS;\n    static ALLOWED_FUNCTIONS: string[] = ['ifElse', 'first'];\n\n    // Export helper classes as static props, to make them testable:\n    static Tokenizer = Tokenizer;\n    static TokenType = TokenType;\n    static Parser = Parser;\n\n    // Create a function blacklist:\n    static functionBlacklist = Object.getOwnPropertyNames(Formula.prototype)\n        .filter((prop) => Formula.prototype[prop] instanceof Function && !this.ALLOWED_FUNCTIONS.includes(prop))\n        .map((prop) => Formula.prototype[prop]);\n\n    public formulaExpression: Expression | null;\n    public options: FormulaOptions;\n    public formulaStr: string;\n    private _variables: string[];\n    private _memory: { [key: string]: any };\n\n    /**\n     * Creates a new Formula instance\n     *\n     * Optional configuration can be set in the options object:\n     *\n     * - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     *\n     * @param {String} fStr The formula string, e.g. 'sin(x)/cos(y)'\n     * @param {Object} options An options object. Supported options:\n     *    - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     * @param {Formula} parentFormula Internally used to build a Formula AST\n     */\n    constructor(fStr: string, options: FormulaOptions | null = {}) {\n        this.formulaExpression = null;\n        this.options = { ...{ memoization: false }, ...options };\n        this.formulaStr = '';\n        this._variables = [];\n        this._memory = {};\n        this.setFormula(fStr);\n    }\n\n    /**\n     * Re-sets the given String and parses it to a formula expression. Can be used after initialization,\n     * to re-use the Formula object.\n     *\n     * @param {String} formulaString The formula string to set/parse\n     * @return {this} The Formula object (this)\n     */\n    setFormula(formulaString: string) {\n        if (formulaString) {\n            this.formulaExpression = null;\n            this._variables = [];\n            this._memory = {};\n            this.formulaStr = formulaString;\n            this.formulaExpression = this.parse(formulaString);\n        }\n        return this;\n    }\n\n    /**\n     * Enable memoization: An expression is only evaluated once for the same input.\n     * Further evaluations with the same input will return the in-memory stored result.\n     */\n    enableMemoization() {\n        this.options.memoization = true;\n    }\n\n    /**\n     * Disable in-memory memoization: each call to evaluate() is executed from scratch.\n     */\n    disableMemoization() {\n        this.options.memoization = false;\n        this._memory = {};\n    }\n\n    /**\n     * Parses the given formula string into an Abstract Syntax Tree (AST).\n     *\n     * The parsing is done in two phases:\n     * 1. Tokenization: Convert the input string into a stream of tokens\n     * 2. Parsing: Convert the token stream into an Expression tree using Pratt parsing\n     *\n     * Example: \"2 + 3 * sin(PI * x)\" is tokenized into:\n     *   [NUMBER(2), OPERATOR(+), NUMBER(3), OPERATOR(*), FUNCTION(sin), ...]\n     * Then parsed into an expression tree:\n     *  ```\n     *         root expr:  (+)\n     *                     / \\\n     *                    2    (*)\n     *                        / \\\n     *                       3   functionExpr(sin, [PI*x])\n     * ```\n     *\n     * @param {String} str The formula string, e.g. '3*sin(PI/x)'\n     * @returns {Expression} An expression object, representing the expression tree\n     */\n    parse(str: string): Expression {\n        // Phase 1: Tokenize the input string\n        // The tokenizer handles whitespace automatically via skipWhitespace()\n        const tokenizer = new Tokenizer();\n        const tokens = tokenizer.tokenize(str);\n\n        // Phase 2: Parse the token stream into an AST\n        const parser = new Parser(tokens, this);\n        return parser.parse();\n    }\n\n    registerVariable(varName: string) {\n        if (this._variables.indexOf(varName) < 0) {\n            this._variables.push(varName);\n        }\n    }\n\n    getVariables() {\n        return this._variables;\n    }\n\n    /**\n     * Evaluates a Formula by delivering values for the Formula's variables.\n     * E.g. if the formula is '3*x^2 + 2*x + 4', you should call `evaulate` as follows:\n     *\n     * evaluate({x:2}) --> Result: 20\n     *\n     * @param {ValueObject|Array<ValueObject>} valueObj An object containing values for variables and (unknown) functions,\n     *   or an array of such objects: If an array is given, all objects are evaluated and the results\n     *   also returned as array.\n     * @return {Number|String|(Number|String)[]} The evaluated result, or an array with results\n     */\n    evaluate(valueObj: ValueObject | ValueObject[]): any {\n        // resolve multiple value objects recursively:\n        if (valueObj instanceof Array) {\n            return valueObj.map((v) => this.evaluate(v));\n        }\n        let expr = this.getExpression();\n        if (!(expr instanceof Expression)) {\n            throw new Error('No expression set: Did you init the object with a Formula?');\n        }\n        if (this.options.memoization) {\n            let res = this.resultFromMemory(valueObj);\n            if (res !== null) {\n                return res;\n            } else {\n                res = expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n                this.storeInMemory(valueObj, res);\n                return res;\n            }\n        }\n        return expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n    }\n\n    hashValues(valueObj: ValueObject) {\n        return JSON.stringify(valueObj);\n    }\n\n    resultFromMemory(valueObj: ValueObject): any {\n        let key = this.hashValues(valueObj);\n        let res = this._memory[key];\n        if (res !== undefined) {\n            return res;\n        } else {\n            return null;\n        }\n    }\n\n    storeInMemory(valueObj: ValueObject, value: any) {\n        this._memory[this.hashValues(valueObj)] = value;\n    }\n\n    getExpression() {\n        return this.formulaExpression;\n    }\n\n    getExpressionString() {\n        return this.formulaExpression ? this.formulaExpression.toString() : '';\n    }\n\n    static calc(formula: string, valueObj: ValueObject | null = null, options = {}) {\n        valueObj = valueObj ?? {};\n        return new Formula(formula, options).evaluate(valueObj);\n    }\n\n    /**\n     * Implements an if/else condition as a function: Checks the predicate\n     * if it evaluates to true-ish (> 0, true, non-empty string, etc.). Returns the trueValue if\n     * the predicate evaluates to true, else the falseValue.\n     * allowed formula functio\n     * @param predicate\n     * @param trueValue\n     * @param falseValue\n     * @returns\n     */\n    ifElse(predicate: any, trueValue: any, falseValue: any): any {\n        if (predicate) {\n            return trueValue;\n        } else {\n            return falseValue;\n        }\n    }\n\n    first(...args: any[]): any {\n        for (const arg of args) {\n            if (arg instanceof Array) {\n                let res = this.first(...arg);\n                if (res) {\n                    return res;\n                }\n            } else {\n                if (arg) {\n                    return arg;\n                }\n            }\n        }\n        if (args.length > 0) {\n            const last = args[args.length - 1];\n            if (last instanceof Array) {\n                return this.first(...last);\n            } else {\n                return last;\n            }\n        }\n        throw new Error('first(): At least one argument is required');\n    }\n}\n"],"names":["TokenType"],"mappings":"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"}