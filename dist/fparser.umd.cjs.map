{"version":3,"file":"fparser.umd.cjs","sources":["../src/helpers.ts","../src/math_function_helper.ts","../src/math_operator_helper.ts","../src/expression.ts","../src/tokenizer.ts","../src/parser.ts","../src/fparser.ts"],"sourcesContent":["\n/**\n * accesses an object's property by evaluating the given path.\n *\n * Example:\n *  - Object: { a: { b: { c: 1 } } }\n *  - Path: ['a', 'b', 'c']\n *  - Result: 1\n *\n * @param object\n * @param path\n * @param fullPath\n * @returns\n */\nexport function getProperty(object: ValueObject, path: string[], fullPath: string) {\n    let curr: (number | string | Function | Object) & { [key: string]: any } = object;\n    let prev: ((number | string | Function | Object) & { [key: string]: any }) | null = null;\n    for (let propName of path) {\n        if (!['object', 'string'].includes(typeof curr)) {\n            throw new Error(`Cannot evaluate ${propName}, property not found (from path ${fullPath})`);\n        }\n        if (typeof curr === 'object' && !(propName in curr)) {\n            throw new Error(`Cannot evaluate ${propName}, property not found (from path ${fullPath})`);\n        }\n        if (typeof curr === 'string' && !curr.hasOwnProperty(propName)) {\n            throw new Error(`Cannot evaluate ${propName}, property not found (from path ${fullPath})`);\n        }\n        prev = curr;\n        curr = curr[propName];\n    }\n\n    // If we have a function that is part of an object (e.g. array.includes()), we need to\n    // bind the scope before returning:\n    if (typeof curr === 'function' && prev) {\n        curr = curr.bind(prev);\n    }\n\n    return curr;\n}","\nexport class MathFunctionHelper {\n    static throwIfNotNumber(value: number | string) {\n        const valueType = typeof value;\n        if (valueType === 'string') {\n            throw new Error('Strings are not allowed in math operations');\n        }\n    }\n}\n","export class MathOperatorHelper {\n    static throwIfNotNumber(value: number | string) {\n        const valueType = typeof value;\n        if (valueType === 'string') {\n            throw new Error('Strings are not allowed in math operations');\n        }\n    }\n}\n","import Formula from \"./fparser\";\nimport { getProperty } from \"./helpers\";\nimport { MathFunctionHelper } from \"./math_function_helper\";\nimport { MathOperatorHelper } from \"./math_operator_helper\";\nimport type { Token } from \"./tokenizer\";\n\n/**\n * Base class for all expressions: An Expression is somethint that eventually evaluates to a\n * final value, like a number, or a string. It can be composed of other expressions, which\n * are evaluated recursively until a final value is reached.\n */\nexport abstract class Expression {\n    /**\n     * Creates an operator expression from a token.\n     * @param operatorToken The operator token (or string for backward compatibility)\n     * @param left Left operand expression\n     * @param right Right operand expression\n     */\n    static createOperatorExpression(\n        operatorToken: Token | string,\n        left: Expression,\n        right: Expression\n    ) {\n        // Extract operator string from token or use directly if it's a string (backward compatibility)\n        const operator = typeof operatorToken === 'string' ? operatorToken : String(operatorToken.value);\n\n        if (operator === '^') {\n            return new PowerExpression(left, right);\n        }\n        if (['*', '/'].includes(operator)) {\n            return new MultDivExpression(operator, left, right);\n        }\n        if (['+', '-'].includes(operator)) {\n            return new PlusMinusExpression(operator, left, right);\n        }\n        if (['<', '>', '<=', '>=', '=', '!='].includes(operator)) {\n            return new LogicalExpression(operator, left, right);\n        }\n        throw new Error(`Unknown operator: ${operator}`);\n    }\n\n    abstract evaluate(params: ValueObject): any;\n\n    toString() {\n        return '';\n    }\n}\n\n/**\n * An unused expression - it is only used during parsing stage, to store a placeholder for a\n * real expression later.\n */\nexport class PlaceholderExpression extends Expression {\n    evaluate(params: ValueObject): number | string {\n        throw new Error('PlaceholderExpression cannot be evaluated');\n    }\n    toString() {\n        return '[placeholder]';\n    }\n}\n\n/**\n * Represents a bracketed expression: (expr)\n * It evaluates its inner expression.\n */\nexport class BracketExpression extends Expression {\n    innerExpression: Expression;\n\n    constructor(expr: Expression) {\n        super();\n        this.innerExpression = expr;\n        if (!(this.innerExpression instanceof Expression)) {\n            throw new Error('No inner expression given for bracket expression');\n        }\n    }\n    evaluate(params = {}): number | string {\n        return this.innerExpression.evaluate(params);\n    }\n    toString() {\n        return `(${this.innerExpression.toString()})`;\n    }\n}\n\n/**\n * Represents a final value, e.g. a number.\n */\nexport class ValueExpression extends Expression {\n    value: number | string;\n    type: string;\n\n    constructor(value: number | string, type: string = 'number') {\n        super();\n        this.value = Number(value);\n        switch (type) {\n            case 'number':\n                this.value = Number(value);\n                if (isNaN(this.value)) {\n                    throw new Error('Cannot parse number: ' + value);\n                }\n                break;\n            case 'string':\n                this.value = String(value);\n                break;\n            default:\n                throw new Error('Invalid value type: ' + type);\n        }\n        this.type = type;\n    }\n    evaluate(): number | string {\n        return this.value;\n    }\n    toString() {\n        switch (this.type) {\n            case 'number':\n                return String(this.value);\n            case 'string':\n                return String('\"' + this.value + '\"');\n            default:\n                throw new Error('Invalid type');\n        }\n    }\n}\n\n/**\n * Represents the '+' or '-' operator expression:\n * it evaluates its left and right expression and returns the sum / difference of the result\n */\nexport class PlusMinusExpression extends Expression {\n    static PLUS = '+';\n    static MINUS = '-';\n\n    operator: string;\n    left: Expression;\n    right: Expression;\n\n    constructor(operator: string, left: Expression, right: Expression) {\n        super();\n        if (!['+', '-'].includes(operator)) {\n            throw new Error(`Operator not allowed in Plus/Minus expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const leftValue = this.left.evaluate(params);\n        const rightValue = this.right.evaluate(params);\n        MathOperatorHelper.throwIfNotNumber(leftValue);\n        MathOperatorHelper.throwIfNotNumber(rightValue);\n        if (this.operator === '+') {\n            return Number(leftValue) + Number(rightValue);\n        }\n        if (this.operator === '-') {\n            return Number(leftValue) - Number(rightValue);\n        }\n        throw new Error('Unknown operator for PlusMinus expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\n/**\n * Represents the '*' or '/' operator expression:\n * it evaluates its left and right expression and returns the product / division of the two.\n */\nexport class MultDivExpression extends Expression {\n    static MULT = '*';\n    static DIV = '/';\n\n    operator: string;\n    left: Expression;\n    right: Expression;\n\n    constructor(operator: string, left: Expression, right: Expression) {\n        super();\n        if (!['*', '/'].includes(operator)) {\n            throw new Error(`Operator not allowed in Multiply/Division expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const leftValue = this.left.evaluate(params);\n        const rightValue = this.right.evaluate(params);\n        MathOperatorHelper.throwIfNotNumber(leftValue);\n        MathOperatorHelper.throwIfNotNumber(rightValue);\n        if (this.operator === '*') {\n            return Number(leftValue) * Number(rightValue);\n        }\n        if (this.operator === '/') {\n            return Number(leftValue) / Number(rightValue);\n        }\n        throw new Error('Unknown operator for MultDiv expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\n/**\n * Represents the 'power of' operator expression:\n * evaluates base^exponent.\n */\nexport class PowerExpression extends Expression {\n    base: Expression;\n    exponent: Expression;\n\n    constructor(base: Expression, exponent: Expression) {\n        super();\n        this.base = base;\n        this.exponent = exponent;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const baseValue = this.base.evaluate(params);\n        const exponentValue = this.exponent.evaluate(params);\n        MathOperatorHelper.throwIfNotNumber(baseValue);\n        MathOperatorHelper.throwIfNotNumber(exponentValue);\n\n        return Math.pow(Number(baseValue), Number(exponentValue));\n    }\n\n    toString() {\n        return `${this.base.toString()}^${this.exponent.toString()}`;\n    }\n}\n\n/**\n * Represents locical operator expressions: All logical operations\n * evaluate either to 0 or 1 (false or true): this way, you can use them in calculations\n * to enable / disable different parts of the formula.\n */\nexport class LogicalExpression extends Expression {\n    static LT = '<';\n    static GT = '>';\n    static LTE = '<=';\n    static GTE = '>=';\n    static EQ = '=';\n    static NEQ = '!=';\n\n    operator: string;\n    left: Expression;\n    right: Expression;\n\n    constructor(operator: string, left: Expression, right: Expression) {\n        super();\n        if (!['<', '>', '<=', '>=', '=', '!='].includes(operator)) {\n            throw new Error(`Operator not allowed in Logical expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const leftValue = this.left.evaluate(params);\n        const rightValue = this.right.evaluate(params);\n        switch (this.operator) {\n            case '<':\n                return leftValue < rightValue ? 1 : 0;\n            case '>':\n                return leftValue > rightValue ? 1 : 0;\n            case '<=':\n                return leftValue <= rightValue ? 1 : 0;\n            case '>=':\n                return leftValue >= rightValue ? 1 : 0;\n            case '=':\n                return leftValue === rightValue ? 1 : 0;\n            case '!=':\n                return leftValue !== rightValue ? 1 : 0;\n        }\n        throw new Error('Unknown operator for Logical expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\n/**\n * Represents a function expression: evaluates the expression in the function arguments,\n * then executes the function with the evaluated arguments, an evaluates the result.\n */\nexport class FunctionExpression extends Expression {\n    fn: string;\n    varPath: string[];\n    argumentExpressions: Expression[];\n    formulaObject: Formula | null;\n    blacklisted: boolean | undefined;\n\n    constructor(fn: string | null, argumentExpressions: Expression[], formulaObject: Formula | null = null) {\n        super();\n        this.fn = fn ?? '';\n        this.varPath = this.fn.split('.');\n        this.argumentExpressions = argumentExpressions || [];\n        this.formulaObject = formulaObject;\n        this.blacklisted = undefined;\n    }\n\n    evaluate(params: ValueObject = {}): number | string {\n        params = params || {};\n        const paramValues = this.argumentExpressions.map((a) => a.evaluate(params));\n\n        // If the params object itself has a function definition with\n        // the function name, call this one:\n        // let fn = params[this.fn];\n        try {\n            let fn = getProperty(params, this.varPath, this.fn);\n            if (fn instanceof Function) {\n                return fn.apply(this, paramValues);\n            }\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n\n        let objFn;\n        try {\n            // perhaps the Formula object has the function? so call it:\n            objFn = getProperty(this.formulaObject ?? {}, this.varPath, this.fn);\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        if (this.formulaObject && objFn instanceof Function) {\n            // Don't, if it is blacklisted:\n            if (this.isBlacklisted()) {\n                throw new Error('Blacklisted function called: ' + this.fn);\n            }\n            return objFn.apply(this.formulaObject, paramValues);\n        }\n\n        try {\n            // Has the JS Math object a function as requested? Call it:\n            const mathFn = getProperty(Math, this.varPath, this.fn);\n            if (mathFn instanceof Function) {\n                paramValues.forEach((paramValue) => {\n                    MathFunctionHelper.throwIfNotNumber(paramValue);\n                });\n\n                return mathFn.apply(this, paramValues);\n            }\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        // No more options left: sorry!\n        throw new Error('Function not found: ' + this.fn);\n    }\n\n    toString() {\n        return `${this.fn}(${this.argumentExpressions.map((a) => a.toString()).join(', ')})`;\n    }\n\n    isBlacklisted() {\n        // cache evaluation of blacklisted function, to save call time:\n        if (this.blacklisted === undefined) {\n            this.blacklisted = Formula.functionBlacklist.includes(\n                this.formulaObject ? this.formulaObject[this.fn] : null\n            );\n        }\n        return this.blacklisted;\n    }\n}\n\nexport class VariableExpression extends Expression {\n    fullPath: string;\n    varPath: string[];\n    formulaObject: Formula | null;\n\n    constructor(fullPath: string, formulaObj: Formula | null = null) {\n        super();\n        this.formulaObject = formulaObj;\n        this.fullPath = fullPath;\n        this.varPath = fullPath.split('.');\n    }\n\n    evaluate(params = {}): any {\n        // params contain variable / value pairs: If this object's variable matches\n        // a varname found in the params, return the value.\n        // eg: params = {x: 5,y:3}, varname = x, return 5\n        // Objects and arrays are also supported:\n        // e.g. params = {x: {y: 5}}, varname = x.y, return 5\n        //  or  params = {x: [2,4,6]}, varname = x.2, return 6\n        // Objects can also be passed as function arguments:\n        // e.g. params = {p1: {x: 1, y: 2}}, varname = p1, return {x: 1, y: 2}\n\n        // Let's look in the value object first:\n        let value = undefined;\n        try {\n            value = getProperty(params, this.varPath, this.fullPath);\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        if (value === undefined) {\n            // Now have a look at the formula object:\n            // This will throw an error if the property is not found:\n            value = getProperty(this.formulaObject ?? {}, this.varPath, this.fullPath);\n        }\n        if (typeof value === 'function') {\n            throw new Error(`Cannot use ${this.fullPath} as value: It is a function and not allowed as a variable value.`);\n        }\n\n        return value;\n    }\n    toString() {\n        return `${this.varPath.join('.')}`;\n    }\n}","/**\n * Tokenizer for Formula Parser\n * Converts a formula string into a stream of tokens\n */\n\nexport enum TokenType {\n    NUMBER = 'NUMBER',\n    VARIABLE = 'VARIABLE',\n    OPERATOR = 'OPERATOR',\n    LOGICAL_OPERATOR = 'LOGICAL_OPERATOR',\n    FUNCTION = 'FUNCTION',\n    LEFT_PAREN = 'LEFT_PAREN',\n    RIGHT_PAREN = 'RIGHT_PAREN',\n    COMMA = 'COMMA',\n    STRING = 'STRING',\n    EOF = 'EOF'\n}\n\nexport interface Token {\n    type: TokenType;\n    value: string | number;\n    raw: string;           // original text from input\n    position: number;      // character position in input\n    length: number;        // length of the token in original input\n}\n\nexport class Tokenizer {\n    private input: string;\n    private position: number;\n\n    // Regex patterns for token matching\n    private static readonly PATTERNS = {\n        WHITESPACE: /^\\s+/,\n        NUMBER: /^-?\\d+(\\.\\d+)?/,\n        IDENTIFIER: /^[a-zA-Z_][a-zA-Z0-9_.]*/,\n        BRACKETED_IDENTIFIER: /^\\[([^\\]]*)\\]/,  // Match anything between brackets, validate later\n        STRING_DOUBLE: /^\"((?:[^\"\\\\]|\\\\.)*)\"/,\n        STRING_SINGLE: /^'((?:[^'\\\\]|\\\\.)*)'/,\n        LOGICAL_OPERATOR: /^(<=|>=|!=|<|>|=)/,\n        OPERATOR: /^[+\\-*/^]/,\n        LEFT_PAREN: /^\\(/,\n        RIGHT_PAREN: /^\\)/,\n        COMMA: /^,/\n    };\n\n    constructor() {\n        this.input = '';\n        this.position = 0;\n    }\n\n    tokenize(input: string): Token[] {\n        this.input = input;\n        this.position = 0;\n        const tokens: Token[] = [];\n\n        while (this.position < this.input.length) {\n            this.skipWhitespace();\n\n            if (this.position >= this.input.length) break;\n\n            const token = this.nextToken(tokens);\n            if (token) {\n                tokens.push(token);\n            }\n        }\n\n        tokens.push({\n            type: TokenType.EOF,\n            value: '',\n            raw: '',\n            position: this.position,\n            length: 0\n        });\n        return tokens;\n    }\n\n    private nextToken(tokens: Token[]): Token | null {\n        // Try each token pattern in order\n        // String must be checked first to avoid conflicts\n        return (\n            this.readString() ||\n            this.readLogicalOperator() ||\n            this.readNumber(tokens) ||\n            this.readOperator() ||\n            this.readParenthesis() ||\n            this.readComma() ||\n            this.readIdentifier() ||\n            this.throwUnexpectedChar()\n        );\n    }\n\n    private skipWhitespace(): void {\n        const remaining = this.input.slice(this.position);\n        const match = remaining.match(Tokenizer.PATTERNS.WHITESPACE);\n        if (match) {\n            this.position += match[0].length;\n        }\n    }\n\n    private remaining(): string {\n        return this.input.slice(this.position);\n    }\n\n    /**\n     * Read a number token. Includes the minus sign if it's unambiguously part of the number.\n     * Handles negative numbers when preceded by operators, commas, left parenthesis, or at start.\n     */\n    private readNumber(tokens: Token[]): Token | null {\n        const start = this.position;\n        const remaining = this.remaining();\n\n        // Try to match a number (with optional negative sign)\n        const match = remaining.match(Tokenizer.PATTERNS.NUMBER);\n        if (!match) {\n            return null;\n        }\n\n        const raw = match[0];\n\n        // If the number starts with '-', check if it's actually a negative number\n        // or if the '-' should be treated as a separate operator\n        if (raw.startsWith('-')) {\n            const prevToken = tokens.length > 0 ? tokens[tokens.length - 1] : null;\n            const canBeNegative =\n                !prevToken ||\n                prevToken.type === TokenType.OPERATOR ||\n                prevToken.type === TokenType.LOGICAL_OPERATOR ||\n                prevToken.type === TokenType.COMMA ||\n                prevToken.type === TokenType.LEFT_PAREN;\n\n            if (!canBeNegative) {\n                // The '-' is an operator, not part of the number\n                return null;\n            }\n        }\n\n        this.position += raw.length;\n        const value = parseFloat(raw);\n\n        return {\n            type: TokenType.NUMBER,\n            value: value,\n            raw: raw,\n            position: start,\n            length: raw.length\n        };\n    }\n\n    /**\n     * Read an identifier (variable or function name).\n     * Supports: myVar, x, PI, my_var, obj.prop, [myVar], [obj.prop]\n     */\n    private readIdentifier(): Token | null {\n        const start = this.position;\n        const remaining = this.remaining();\n\n        // Try bracketed identifier first: [varname]\n        let match = remaining.match(Tokenizer.PATTERNS.BRACKETED_IDENTIFIER);\n        if (match) {\n            const raw = match[0];\n            const value = match[1]; // captured group without brackets\n\n            if (value === '') {\n                throw new Error(`Empty bracketed variable at position ${start}`);\n            }\n\n            // Validate that the content only contains valid identifier characters\n            if (!/^[a-zA-Z0-9_.]+$/.test(value)) {\n                // Find the first invalid character\n                const invalidCharMatch = value.match(/[^a-zA-Z0-9_.]/);\n                const invalidChar = invalidCharMatch ? invalidCharMatch[0] : value[0];\n                const invalidCharPos = start + 1 + value.indexOf(invalidChar);\n                throw new Error(\n                    `Invalid character '${invalidChar}' in bracketed variable at position ${invalidCharPos}`\n                );\n            }\n\n            this.position += raw.length;\n\n            // Look ahead to determine if this is a function call\n            const savedPos = this.position;\n            this.skipWhitespace();\n            const isFunction = this.position < this.input.length && this.input[this.position] === '(';\n            this.position = savedPos; // restore position\n\n            return {\n                type: isFunction ? TokenType.FUNCTION : TokenType.VARIABLE,\n                value: value,\n                raw: raw,\n                position: start,\n                length: raw.length\n            };\n        }\n\n        // Try regular identifier: myVar, x, PI\n        match = remaining.match(Tokenizer.PATTERNS.IDENTIFIER);\n        if (match) {\n            const raw = match[0];\n            const value = raw;\n            this.position += raw.length;\n\n            // Look ahead to determine if this is a function call\n            const savedPos = this.position;\n            this.skipWhitespace();\n            const isFunction = this.position < this.input.length && this.input[this.position] === '(';\n            this.position = savedPos; // restore position\n\n            return {\n                type: isFunction ? TokenType.FUNCTION : TokenType.VARIABLE,\n                value: value,\n                raw: raw,\n                position: start,\n                length: raw.length\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * Read a string literal (single or double quoted).\n     * Supports escaped quotes: \\\" or \\'\n     */\n    private readString(): Token | null {\n        const start = this.position;\n        const remaining = this.remaining();\n\n        // Try double-quoted string\n        let match = remaining.match(Tokenizer.PATTERNS.STRING_DOUBLE);\n        if (match) {\n            const raw = match[0];\n            const capturedValue = match[1]; // content between quotes\n            // Process escape sequences: \\\\ -> \\, \\\" -> \"\n            const value = capturedValue.replace(/\\\\(.)/g, '$1');\n            this.position += raw.length;\n\n            return {\n                type: TokenType.STRING,\n                value: value,\n                raw: raw,\n                position: start,\n                length: raw.length\n            };\n        }\n\n        // Try single-quoted string\n        match = remaining.match(Tokenizer.PATTERNS.STRING_SINGLE);\n        if (match) {\n            const raw = match[0];\n            const capturedValue = match[1]; // content between quotes\n            // Process escape sequences: \\\\ -> \\, \\' -> '\n            const value = capturedValue.replace(/\\\\(.)/g, '$1');\n            this.position += raw.length;\n\n            return {\n                type: TokenType.STRING,\n                value: value,\n                raw: raw,\n                position: start,\n                length: raw.length\n            };\n        }\n\n        // Check for unterminated string\n        if (remaining.startsWith('\"') || remaining.startsWith(\"'\")) {\n            throw new Error(`Unterminated string at position ${start}`);\n        }\n\n        return null;\n    }\n\n    /**\n     * Read a simple operator: +, -, *, /, ^\n     */\n    private readOperator(): Token | null {\n        const start = this.position;\n        const remaining = this.remaining();\n\n        const match = remaining.match(Tokenizer.PATTERNS.OPERATOR);\n        if (!match) {\n            return null;\n        }\n\n        const raw = match[0];\n        this.position += raw.length;\n\n        return {\n            type: TokenType.OPERATOR,\n            value: raw,\n            raw: raw,\n            position: start,\n            length: raw.length\n        };\n    }\n\n    /**\n     * Read a logical operator: <, >, <=, >=, =, !=\n     */\n    private readLogicalOperator(): Token | null {\n        const start = this.position;\n        const remaining = this.remaining();\n\n        // Check for invalid '!' operator\n        if (remaining.startsWith('!') && !remaining.startsWith('!=')) {\n            throw new Error(`Invalid operator '!' at position ${start}. Did you mean '!='?`);\n        }\n\n        const match = remaining.match(Tokenizer.PATTERNS.LOGICAL_OPERATOR);\n        if (!match) {\n            return null;\n        }\n\n        const raw = match[0];\n        this.position += raw.length;\n\n        return {\n            type: TokenType.LOGICAL_OPERATOR,\n            value: raw,\n            raw: raw,\n            position: start,\n            length: raw.length\n        };\n    }\n\n    /**\n     * Read parentheses\n     */\n    private readParenthesis(): Token | null {\n        const start = this.position;\n        const remaining = this.remaining();\n\n        // Try left parenthesis\n        let match = remaining.match(Tokenizer.PATTERNS.LEFT_PAREN);\n        if (match) {\n            const raw = match[0];\n            this.position += raw.length;\n            return {\n                type: TokenType.LEFT_PAREN,\n                value: raw,\n                raw: raw,\n                position: start,\n                length: raw.length\n            };\n        }\n\n        // Try right parenthesis\n        match = remaining.match(Tokenizer.PATTERNS.RIGHT_PAREN);\n        if (match) {\n            const raw = match[0];\n            this.position += raw.length;\n            return {\n                type: TokenType.RIGHT_PAREN,\n                value: raw,\n                raw: raw,\n                position: start,\n                length: raw.length\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * Read comma separator\n     */\n    private readComma(): Token | null {\n        const start = this.position;\n        const remaining = this.remaining();\n\n        const match = remaining.match(Tokenizer.PATTERNS.COMMA);\n        if (!match) {\n            return null;\n        }\n\n        const raw = match[0];\n        this.position += raw.length;\n\n        return {\n            type: TokenType.COMMA,\n            value: raw,\n            raw: raw,\n            position: start,\n            length: raw.length\n        };\n    }\n\n    /**\n     * Throw an error for unexpected characters\n     */\n    private throwUnexpectedChar(): never {\n        const char = this.input[this.position] || 'EOF';\n        throw new Error(`Unexpected character '${char}' at position ${this.position}`);\n    }\n}\n","/**\n * Parser for Formula Parser\n * Converts a stream of tokens into an Abstract Syntax Tree (AST)\n * Uses Pratt parsing algorithm for operator precedence\n */\n\nimport { Token, TokenType } from './tokenizer';\nimport {\n    Expression,\n    BracketExpression,\n    ValueExpression,\n    VariableExpression,\n    FunctionExpression,\n    MultDivExpression\n} from './expression';\nimport Formula from './fparser';\n\n/**\n * Operator precedence levels (higher = tighter binding)\n */\nconst PRECEDENCE = {\n    // Logical operators (lowest precedence)\n    '=': 1,\n    '!=': 1,\n    '<': 1,\n    '>': 1,\n    '<=': 1,\n    '>=': 1,\n\n    // Addition/Subtraction\n    '+': 2,\n    '-': 2,\n\n    // Multiplication/Division\n    '*': 3,\n    '/': 3,\n\n    // Power (highest precedence, right-associative)\n    '^': 4\n};\n\n/**\n * Parser class that builds an AST from tokens\n */\nexport class Parser {\n    private tokens: Token[];\n    private current: number;\n    private formulaObject: Formula;\n\n    constructor(tokens: Token[], formulaObject: Formula) {\n        this.tokens = tokens;\n        this.current = 0;\n        this.formulaObject = formulaObject;\n    }\n\n    /**\n     * Main entry point: Parse the token stream into an Expression tree\n     */\n    parse(): Expression {\n        const expr = this.parseExpression(0);\n        if (!this.isAtEnd()) {\n            const token = this.peek();\n            throw new Error(\n                `Unexpected token '${token.value}' at position ${token.position}: Expected end of expression`\n            );\n        }\n        return expr;\n    }\n\n    /**\n     * Pratt parsing: handles operator precedence elegantly\n     * @param minPrecedence Minimum precedence level to parse\n     */\n    private parseExpression(minPrecedence: number): Expression {\n        let left = this.parsePrimary();\n\n        while (!this.isAtEnd()) {\n            const token = this.peek();\n\n            // Stop if we hit a non-operator token (parenthesis, comma, etc.)\n            if (token.type !== TokenType.OPERATOR && token.type !== TokenType.LOGICAL_OPERATOR) {\n                break;\n            }\n\n            const precedence = this.getPrecedence(token);\n\n            if (precedence < minPrecedence) break;\n\n            // Handle right-associative operators (power)\n            const isRightAssociative = token.value === '^';\n            const nextPrecedence = isRightAssociative ? precedence : precedence + 1;\n\n            this.consume();\n            const right = this.parseExpression(nextPrecedence);\n\n            left = Expression.createOperatorExpression(\n                token,\n                left,\n                right\n            );\n        }\n\n        return left;\n    }\n\n    /**\n     * Parse primary expressions: numbers, variables, functions, parentheses, unary operators\n     */\n    private parsePrimary(): Expression {\n        const token = this.peek();\n\n        // Handle unary minus: convert to -1 * expr\n        if (this.match(TokenType.OPERATOR) && token.value === '-') {\n            this.consume();\n            const expr = this.parsePrimary();\n            return new MultDivExpression('*', new ValueExpression(-1), expr);\n        }\n\n        // Handle unary plus: just skip it\n        if (this.match(TokenType.OPERATOR) && token.value === '+') {\n            this.consume();\n            return this.parsePrimary();\n        }\n\n        // Numbers\n        if (this.match(TokenType.NUMBER)) {\n            this.consume();\n            return new ValueExpression(token.value);\n        }\n\n        // Strings\n        if (this.match(TokenType.STRING)) {\n            this.consume();\n            return new ValueExpression(token.value, 'string');\n        }\n\n        // Parenthesized expressions\n        if (this.match(TokenType.LEFT_PAREN)) {\n            return this.parseParenthesizedExpression();\n        }\n\n        // Variables or Functions\n        if (this.match(TokenType.VARIABLE, TokenType.FUNCTION)) {\n            return this.parseVariableOrFunction();\n        }\n\n        throw new Error(\n            `Unexpected token '${token.value}' at position ${token.position}: Expected number, variable, function, or '('`\n        );\n    }\n\n    /**\n     * Parse a parenthesized expression: (expr)\n     */\n    private parseParenthesizedExpression(): Expression {\n        const leftParen = this.consume(TokenType.LEFT_PAREN);\n        const expr = this.parseExpression(0);\n\n        if (!this.match(TokenType.RIGHT_PAREN)) {\n            const token = this.peek();\n            throw new Error(\n                `Missing closing parenthesis at position ${token.position}: Expected ')' to match '(' at position ${leftParen.position}`\n            );\n        }\n\n        this.consume(TokenType.RIGHT_PAREN);\n        return new BracketExpression(expr);\n    }\n\n    /**\n     * Parse a variable or function call\n     */\n    private parseVariableOrFunction(): Expression {\n        const token = this.consume();\n        const name = token.value as string;\n\n        // Check if it's a function call (next token is '(')\n        if (this.match(TokenType.LEFT_PAREN)) {\n            return this.parseFunctionCall(name, token.position);\n        }\n\n        // It's a variable\n        this.formulaObject.registerVariable(name);\n        return new VariableExpression(name, this.formulaObject);\n    }\n\n    /**\n     * Parse a function call: functionName(arg1, arg2, ...)\n     */\n    private parseFunctionCall(name: string, namePosition: number): Expression {\n        const leftParen = this.consume(TokenType.LEFT_PAREN);\n        const args: Expression[] = [];\n\n        // Parse arguments (if any)\n        if (!this.match(TokenType.RIGHT_PAREN)) {\n            do {\n                args.push(this.parseExpression(0));\n            } while (this.matchAndConsume(TokenType.COMMA));\n        }\n\n        if (!this.match(TokenType.RIGHT_PAREN)) {\n            const token = this.peek();\n            throw new Error(\n                `Missing closing parenthesis for function '${name}' at position ${token.position}: Expected ')' to match '(' at position ${leftParen.position}`\n            );\n        }\n\n        this.consume(TokenType.RIGHT_PAREN);\n        return new FunctionExpression(name, args, this.formulaObject);\n    }\n\n    // ==================== Helper Methods ====================\n\n    /**\n     * Get the current token without consuming it\n     */\n    private peek(): Token {\n        return this.tokens[this.current];\n    }\n\n    /**\n     * Consume the current token and move to the next one\n     * @param expected Optional: throw error if current token is not of this type\n     */\n    private consume(expected?: TokenType): Token {\n        const token = this.peek();\n        if (expected && token.type !== expected) {\n            throw new Error(\n                `Expected ${expected} at position ${token.position}, got ${token.type} ('${token.value}')`\n            );\n        }\n        this.current++;\n        return token;\n    }\n\n    /**\n     * Check if the current token matches any of the given types\n     */\n    private match(...types: TokenType[]): boolean {\n        return types.includes(this.peek().type);\n    }\n\n    /**\n     * If the current token matches the given type, consume it and return true\n     */\n    private matchAndConsume(type: TokenType): boolean {\n        if (this.match(type)) {\n            this.consume();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Check if we've reached the end of the token stream\n     */\n    private isAtEnd(): boolean {\n        return this.peek().type === TokenType.EOF;\n    }\n\n    /**\n     * Get the precedence level for a token\n     */\n    private getPrecedence(token: Token): number {\n        if (token.type === TokenType.LOGICAL_OPERATOR) {\n            const op = token.value as string;\n            return PRECEDENCE[op as keyof typeof PRECEDENCE] ?? 0;\n        }\n        if (token.type === TokenType.OPERATOR) {\n            const op = token.value as string;\n            return PRECEDENCE[op as keyof typeof PRECEDENCE] ?? 0;\n        }\n        return 0;\n    }\n}\n","import {\n    BracketExpression,\n    Expression,\n    FunctionExpression,\n    LogicalExpression,\n    MultDivExpression,\n    PlusMinusExpression,\n    PowerExpression,\n    ValueExpression,\n    VariableExpression\n} from './expression';\n\nimport { Tokenizer, TokenType } from './tokenizer';\n// import type  { Token } from './tokenizer';\nimport { Parser } from './parser';\n\n/**\n * JS Formula Parser\n * -------------------\n * (c) 2012-2024 Alexander Schenkel, alex@alexi.ch\n *\n * JS Formula Parser takes a string, parses its mathmatical formula\n * and creates an evaluatable Formula object of it.\n *\n * Example input:\n *\n * var fObj = new Formula('sin(PI*x)/(2*PI)');\n * var result = fObj.evaluate({x: 2});\n * var results = fObj.evaluate([\n *     {x: 2},\n *     {x: 4},\n *     {x: 8}\n * ]);\n *\n * LICENSE:\n * -------------\n * MIT license, see LICENSE file\n */\nconst MATH_CONSTANTS = {\n    PI: Math.PI,\n    E: Math.E,\n    LN2: Math.LN2,\n    LN10: Math.LN10,\n    LOG2E: Math.LOG2E,\n    LOG10E: Math.LOG10E,\n    SQRT1_2: Math.SQRT1_2,\n    SQRT2: Math.SQRT2\n};\n\ndeclare global {\n    interface Math {\n        [key: string]: number | Function;\n    }\n}\n\n/**\n * Evaluates a variable within a formula to its value. The variable value\n * is expected to be given in the evaluate() method or on the formula object.\n */\n\n/**\n * The Formula class represents a mathematical formula, including functions to evaluate\n * the formula to its final result.\n *\n * Usage example:\n *\n * 1. Create a Formula object instance by passing a formula string:\n * const fObj = new Formula('2^x');\n *\n * 2. evaluate the formula, delivering a value object for each unknown entity:\n * let result = fObj.evaluate({ x: 3 }); // result = 8\n */\nexport default class Formula {\n    [key: string]: any;\n    static Expression = Expression;\n    static BracketExpression = BracketExpression;\n    static PowerExpression = PowerExpression;\n    static MultDivExpression = MultDivExpression;\n    static PlusMinusExpression = PlusMinusExpression;\n    static LogicalExpression = LogicalExpression;\n    static ValueExpression = ValueExpression;\n    static VariableExpression = VariableExpression;\n    static FunctionExpression = FunctionExpression;\n    static MATH_CONSTANTS = MATH_CONSTANTS;\n    static ALLOWED_FUNCTIONS: string[] = ['ifElse', 'first'];\n\n    static Tokenizer = Tokenizer;\n    static TokenType = TokenType;\n    static Parser = Parser;\n\n    // export { Tokenizer, TokenType } from './tokenizer';\n    // export type { Token } from './tokenizer';\n    // export { Parser } from './parser';\n\n    // Create a function blacklist:\n    static functionBlacklist = Object.getOwnPropertyNames(Formula.prototype)\n        .filter((prop) => Formula.prototype[prop] instanceof Function && !this.ALLOWED_FUNCTIONS.includes(prop))\n        .map((prop) => Formula.prototype[prop]);\n\n    public formulaExpression: Expression | null;\n    public options: FormulaOptions;\n    public formulaStr: string;\n    private _variables: string[];\n    private _memory: { [key: string]: any };\n\n    /**\n     * Creates a new Formula instance\n     *\n     * Optional configuration can be set in the options object:\n     *\n     * - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     *\n     * @param {String} fStr The formula string, e.g. 'sin(x)/cos(y)'\n     * @param {Object} options An options object. Supported options:\n     *    - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     * @param {Formula} parentFormula Internally used to build a Formula AST\n     */\n    constructor(fStr: string, options: FormulaOptions | null = {}) {\n        this.formulaExpression = null;\n        this.options = { ...{ memoization: false }, ...options };\n        this.formulaStr = '';\n        this._variables = [];\n        this._memory = {};\n        this.setFormula(fStr);\n    }\n\n    /**\n     * Re-sets the given String and parses it to a formula expression. Can be used after initialization,\n     * to re-use the Formula object.\n     *\n     * @param {String} formulaString The formula string to set/parse\n     * @return {this} The Formula object (this)\n     */\n    setFormula(formulaString: string) {\n        if (formulaString) {\n            this.formulaExpression = null;\n            this._variables = [];\n            this._memory = {};\n            this.formulaStr = formulaString;\n            this.formulaExpression = this.parse(formulaString);\n        }\n        return this;\n    }\n\n    /**\n     * Enable memoization: An expression is only evaluated once for the same input.\n     * Further evaluations with the same input will return the in-memory stored result.\n     */\n    enableMemoization() {\n        this.options.memoization = true;\n    }\n\n    /**\n     * Disable in-memory memoization: each call to evaluate() is executed from scratch.\n     */\n    disableMemoization() {\n        this.options.memoization = false;\n        this._memory = {};\n    }\n\n    /**\n     * Parses the given formula string into an Abstract Syntax Tree (AST).\n     *\n     * The parsing is done in two phases:\n     * 1. Tokenization: Convert the input string into a stream of tokens\n     * 2. Parsing: Convert the token stream into an Expression tree using Pratt parsing\n     *\n     * Example: \"2 + 3 * sin(PI * x)\" is tokenized into:\n     *   [NUMBER(2), OPERATOR(+), NUMBER(3), OPERATOR(*), FUNCTION(sin), ...]\n     * Then parsed into an expression tree:\n     *  ```\n     *         root expr:  (+)\n     *                     / \\\n     *                    2    (*)\n     *                        / \\\n     *                       3   functionExpr(sin, [PI*x])\n     * ```\n     *\n     * @param {String} str The formula string, e.g. '3*sin(PI/x)'\n     * @returns {Expression} An expression object, representing the expression tree\n     */\n    parse(str: string): Expression {\n        // Phase 1: Tokenize the input string\n        // The tokenizer handles whitespace automatically via skipWhitespace()\n        const tokenizer = new Tokenizer();\n        const tokens = tokenizer.tokenize(str);\n\n        // Phase 2: Parse the token stream into an AST\n        const parser = new Parser(tokens, this);\n        return parser.parse();\n    }\n\n    registerVariable(varName: string) {\n        if (this._variables.indexOf(varName) < 0) {\n            this._variables.push(varName);\n        }\n    }\n\n    getVariables() {\n        return this._variables;\n    }\n\n    /**\n     * Evaluates a Formula by delivering values for the Formula's variables.\n     * E.g. if the formula is '3*x^2 + 2*x + 4', you should call `evaulate` as follows:\n     *\n     * evaluate({x:2}) --> Result: 20\n     *\n     * @param {ValueObject|Array<ValueObject>} valueObj An object containing values for variables and (unknown) functions,\n     *   or an array of such objects: If an array is given, all objects are evaluated and the results\n     *   also returned as array.\n     * @return {Number|String|(Number|String)[]} The evaluated result, or an array with results\n     */\n    evaluate(valueObj: ValueObject | ValueObject[]): any {\n        // resolve multiple value objects recursively:\n        if (valueObj instanceof Array) {\n            return valueObj.map((v) => this.evaluate(v));\n        }\n        let expr = this.getExpression();\n        if (!(expr instanceof Expression)) {\n            throw new Error('No expression set: Did you init the object with a Formula?');\n        }\n        if (this.options.memoization) {\n            let res = this.resultFromMemory(valueObj);\n            if (res !== null) {\n                return res;\n            } else {\n                res = expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n                this.storeInMemory(valueObj, res);\n                return res;\n            }\n        }\n        return expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n    }\n\n    hashValues(valueObj: ValueObject) {\n        return JSON.stringify(valueObj);\n    }\n\n    resultFromMemory(valueObj: ValueObject): any {\n        let key = this.hashValues(valueObj);\n        let res = this._memory[key];\n        if (res !== undefined) {\n            return res;\n        } else {\n            return null;\n        }\n    }\n\n    storeInMemory(valueObj: ValueObject, value: any) {\n        this._memory[this.hashValues(valueObj)] = value;\n    }\n\n    getExpression() {\n        return this.formulaExpression;\n    }\n\n    getExpressionString() {\n        return this.formulaExpression ? this.formulaExpression.toString() : '';\n    }\n\n    static calc(formula: string, valueObj: ValueObject | null = null, options = {}) {\n        valueObj = valueObj ?? {};\n        return new Formula(formula, options).evaluate(valueObj);\n    }\n\n    /**\n     * Implements an if/else condition as a function: Checks the predicate\n     * if it evaluates to true-ish (> 0, true, non-empty string, etc.). Returns the trueValue if\n     * the predicate evaluates to true, else the falseValue.\n     * allowed formula functio\n     * @param predicate\n     * @param trueValue\n     * @param falseValue\n     * @returns\n     */\n    ifElse(predicate: any, trueValue: any, falseValue: any): any {\n        if (predicate) {\n            return trueValue;\n        } else {\n            return falseValue;\n        }\n    }\n\n    first(...args: any[]): any {\n        for (const arg of args) {\n            if (arg instanceof Array) {\n                let res = this.first(...arg);\n                if (res) {\n                    return res;\n                }\n            } else {\n                if (arg) {\n                    return arg;\n                }\n            }\n        }\n        if (args.length > 0) {\n            const last = args[args.length - 1];\n            if (last instanceof Array) {\n                return this.first(...last);\n            } else {\n                return last;\n            }\n        }\n        throw new Error('first(): At least one argument is required');\n    }\n}\n"],"names":["getProperty","object","path","fullPath","curr","prev","propName","MathFunctionHelper","value","MathOperatorHelper","Expression","operatorToken","left","right","operator","PowerExpression","MultDivExpression","PlusMinusExpression","LogicalExpression","BracketExpression","expr","__publicField","params","ValueExpression","type","leftValue","rightValue","base","exponent","baseValue","exponentValue","FunctionExpression","fn","argumentExpressions","formulaObject","paramValues","a","e","objFn","_a","mathFn","paramValue","Formula","VariableExpression","formulaObj","TokenType","_Tokenizer","input","tokens","token","match","start","raw","prevToken","remaining","invalidCharMatch","invalidChar","invalidCharPos","savedPos","isFunction","char","Tokenizer","PRECEDENCE","Parser","minPrecedence","precedence","nextPrecedence","leftParen","name","namePosition","args","expected","types","op","_b","MATH_CONSTANTS","_Formula","fStr","options","formulaString","str","varName","valueObj","v","res","key","formula","predicate","trueValue","falseValue","arg","last","prop"],"mappings":"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"}