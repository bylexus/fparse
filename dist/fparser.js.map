{"version":3,"file":"fparser.js","sources":["../src/fparser.ts"],"sourcesContent":["/**\n * JS Formula Parser\n * -------------------\n * (c) 2012-2024 Alexander Schenkel, alex@alexi.ch\n *\n * JS Formula Parser takes a string, parses its mathmatical formula\n * and creates an evaluatable Formula object of it.\n *\n * Example input:\n *\n * var fObj = new Formula('sin(PI*x)/(2*PI)');\n * var result = fObj.evaluate({x: 2});\n * var results = fObj.evaluate([\n *     {x: 2},\n *     {x: 4},\n *     {x: 8}\n * ]);\n *\n * LICENSE:\n * -------------\n * MIT license, see LICENSE file\n */\nconst MATH_CONSTANTS = {\n    PI: Math.PI,\n    E: Math.E,\n    LN2: Math.LN2,\n    LN10: Math.LN10,\n    LOG2E: Math.LOG2E,\n    LOG10E: Math.LOG10E,\n    SQRT1_2: Math.SQRT1_2,\n    SQRT2: Math.SQRT2\n};\n\ndeclare global {\n    interface Math {\n        [key: string]: number | Function;\n    }\n}\n\ntype FormulaOptions = {\n    memoization?: boolean;\n};\n\ntype ValueObject = {\n    [key: string]: number | string | Function | ValueObject;\n};\n\nclass MathOperatorHelper {\n    static throwIfNotNumber(value: number | string) {\n        const valueType = typeof value;\n        if (valueType === 'string') {\n            throw new Error('Strings are not allowed in math operations');\n        }\n    }\n}\n\nclass MathFunctionHelper {\n    static throwIfNotNumber(value: number | string) {\n        const valueType = typeof value;\n        if (valueType === 'string') {\n            throw new Error('Strings are not allowed in math operations');\n        }\n    }\n}\n\n/**\n * Base class for all expressions: An Expression is somethint that eventually evaluates to a\n * final value, like a number, or a string. It can be composed of other expressions, which\n * are evaluated recursively until a final value is reached.\n */\nabstract class Expression {\n    static createOperatorExpression(operator: string, left: Expression, right: Expression) {\n        if (operator === '^') {\n            return new PowerExpression(left, right);\n        }\n        if (['*', '/'].includes(operator)) {\n            return new MultDivExpression(operator, left, right);\n        }\n        if (['+', '-'].includes(operator)) {\n            return new PlusMinusExpression(operator, left, right);\n        }\n        if (['<', '>', '<=', '>=', '=', '!='].includes(operator)) {\n            return new LogicalExpression(operator, left, right);\n        }\n        throw new Error(`Unknown operator: ${operator}`);\n    }\n\n    abstract evaluate(params: ValueObject): number | string;\n\n    toString() {\n        return '';\n    }\n}\n\n/**\n * An unused expression - it is only used during parsing stage, to store a placeholder for a\n * real expression later.\n */\nclass PlaceholderExpression extends Expression {\n    evaluate(params: ValueObject): number | string {\n        throw new Error('PlaceholderExpression cannot be evaluated');\n    }\n    toString() {\n        return '[placeholder]';\n    }\n}\n\n/**\n * Represents a bracketed expression: (expr)\n * It evaluates its inner expression.\n */\nclass BracketExpression extends Expression {\n    innerExpression: Expression;\n\n    constructor(expr: Expression) {\n        super();\n        this.innerExpression = expr;\n        if (!(this.innerExpression instanceof Expression)) {\n            throw new Error('No inner expression given for bracket expression');\n        }\n    }\n    evaluate(params = {}): number | string {\n        return this.innerExpression.evaluate(params);\n    }\n    toString() {\n        return `(${this.innerExpression.toString()})`;\n    }\n}\n\n/**\n * Represents a final value, e.g. a number.\n */\nclass ValueExpression extends Expression {\n    value: number | string;\n    type: string;\n\n    constructor(value: number | string, type: string = 'number') {\n        super();\n        this.value = Number(value);\n        switch (type) {\n            case 'number':\n                this.value = Number(value);\n                if (isNaN(this.value)) {\n                    throw new Error('Cannot parse number: ' + value);\n                }\n                break;\n            case 'string':\n                this.value = String(value);\n                break;\n            default:\n                throw new Error('Invalid value type: ' + type);\n        }\n        this.type = type;\n    }\n    evaluate(): number | string {\n        return this.value;\n    }\n    toString() {\n        switch (this.type) {\n            case 'number':\n                return String(this.value);\n            case 'string':\n                return String('\"' + this.value + '\"');\n            default:\n                throw new Error('Invalid type');\n        }\n    }\n}\n\n/**\n * Represents the '+' or '-' operator expression:\n * it evaluates its left and right expression and returns the sum / difference of the result\n */\nclass PlusMinusExpression extends Expression {\n    static PLUS = '+';\n    static MINUS = '-';\n\n    operator: string;\n    left: Expression;\n    right: Expression;\n\n    constructor(operator: string, left: Expression, right: Expression) {\n        super();\n        if (!['+', '-'].includes(operator)) {\n            throw new Error(`Operator not allowed in Plus/Minus expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const leftValue = this.left.evaluate(params);\n        const rightValue = this.right.evaluate(params);\n        MathOperatorHelper.throwIfNotNumber(leftValue);\n        MathOperatorHelper.throwIfNotNumber(rightValue);\n        if (this.operator === '+') {\n            return Number(leftValue) + Number(rightValue);\n        }\n        if (this.operator === '-') {\n            return Number(leftValue) - Number(rightValue);\n        }\n        throw new Error('Unknown operator for PlusMinus expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\n/**\n * Represents the '*' or '/' operator expression:\n * it evaluates its left and right expression and returns the product / division of the two.\n */\nclass MultDivExpression extends Expression {\n    static MULT = '*';\n    static DIV = '/';\n\n    operator: string;\n    left: Expression;\n    right: Expression;\n\n    constructor(operator: string, left: Expression, right: Expression) {\n        super();\n        if (!['*', '/'].includes(operator)) {\n            throw new Error(`Operator not allowed in Multiply/Division expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const leftValue = this.left.evaluate(params);\n        const rightValue = this.right.evaluate(params);\n        MathOperatorHelper.throwIfNotNumber(leftValue);\n        MathOperatorHelper.throwIfNotNumber(rightValue);\n        if (this.operator === '*') {\n            return Number(leftValue) * Number(rightValue);\n        }\n        if (this.operator === '/') {\n            return Number(leftValue) / Number(rightValue);\n        }\n        throw new Error('Unknown operator for MultDiv expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\n/**\n * Represents the 'power of' operator expression:\n * evaluates base^exponent.\n */\nclass PowerExpression extends Expression {\n    base: Expression;\n    exponent: Expression;\n\n    constructor(base: Expression, exponent: Expression) {\n        super();\n        this.base = base;\n        this.exponent = exponent;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const baseValue = this.base.evaluate(params);\n        const exponentValue = this.exponent.evaluate(params);\n        MathOperatorHelper.throwIfNotNumber(baseValue);\n        MathOperatorHelper.throwIfNotNumber(exponentValue);\n\n        return Math.pow(Number(baseValue), Number(exponentValue));\n    }\n\n    toString() {\n        return `${this.base.toString()}^${this.exponent.toString()}`;\n    }\n}\n\n/**\n * Represents locical operator expressions: All logical operations\n * evaluate either to 0 or 1 (false or true): this way, you can use them in calculations\n * to enable / disable different parts of the formula.\n */\nclass LogicalExpression extends Expression {\n    static LT = '<';\n    static GT = '>';\n    static LTE = '<=';\n    static GTE = '>=';\n    static EQ = '=';\n    static NEQ = '!=';\n\n    operator: string;\n    left: Expression;\n    right: Expression;\n\n    constructor(operator: string, left: Expression, right: Expression) {\n        super();\n        if (!['<', '>', '<=', '>=', '=', '!='].includes(operator)) {\n            throw new Error(`Operator not allowed in Logical expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const leftValue = this.left.evaluate(params);\n        const rightValue = this.right.evaluate(params);\n        switch (this.operator) {\n            case '<':\n                return leftValue < rightValue ? 1 : 0;\n            case '>':\n                return leftValue > rightValue ? 1 : 0;\n            case '<=':\n                return leftValue <= rightValue ? 1 : 0;\n            case '>=':\n                return leftValue >= rightValue ? 1 : 0;\n            case '=':\n                return leftValue === rightValue ? 1 : 0;\n            case '!=':\n                return leftValue !== rightValue ? 1 : 0;\n        }\n        throw new Error('Unknown operator for Logical expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\n/**\n * Represents a function expression: evaluates the expression in the function arguments,\n * then executes the function with the evaluated arguments, an evaluates the result.\n */\nclass FunctionExpression extends Expression {\n    fn: string;\n    varPath: string[];\n    argumentExpressions: Expression[];\n    formulaObject: Formula | null;\n    blacklisted: boolean | undefined;\n\n    constructor(fn: string | null, argumentExpressions: Expression[], formulaObject: Formula | null = null) {\n        super();\n        this.fn = fn ?? '';\n        this.varPath = this.fn.split('.');\n        this.argumentExpressions = argumentExpressions || [];\n        this.formulaObject = formulaObject;\n        this.blacklisted = undefined;\n    }\n\n    evaluate(params: ValueObject = {}): number | string {\n        params = params || {};\n        const paramValues = this.argumentExpressions.map((a) => a.evaluate(params));\n\n        // If the params object itself has a function definition with\n        // the function name, call this one:\n        // let fn = params[this.fn];\n        try {\n            let fn = getProperty(params, this.varPath, this.fn);\n            if (fn instanceof Function) {\n                return fn.apply(this, paramValues);\n            }\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n\n        let objFn;\n        try {\n            // perhaps the Formula object has the function? so call it:\n            objFn = getProperty(this.formulaObject ?? {}, this.varPath, this.fn);\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        if (this.formulaObject && objFn instanceof Function) {\n            // Don't, if it is blacklisted:\n            if (this.isBlacklisted()) {\n                throw new Error('Blacklisted function called: ' + this.fn);\n            }\n            return objFn.apply(this.formulaObject, paramValues);\n        }\n\n        try {\n            // Has the JS Math object a function as requested? Call it:\n            const mathFn = getProperty(Math, this.varPath, this.fn);\n            if (mathFn instanceof Function) {\n                paramValues.forEach((paramValue) => {\n                    MathFunctionHelper.throwIfNotNumber(paramValue);\n                });\n\n                return mathFn.apply(this, paramValues);\n            }\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        // No more options left: sorry!\n        throw new Error('Function not found: ' + this.fn);\n    }\n\n    toString() {\n        return `${this.fn}(${this.argumentExpressions.map((a) => a.toString()).join(', ')})`;\n    }\n\n    isBlacklisted() {\n        // cache evaluation of blacklisted function, to save call time:\n        if (this.blacklisted === undefined) {\n            this.blacklisted = Formula.functionBlacklist.includes(\n                this.formulaObject ? this.formulaObject[this.fn] : null\n            );\n        }\n        return this.blacklisted;\n    }\n}\n\n/**\n * accesses an object's property by evaluating the given path.\n *\n * Example:\n *  - Object: { a: { b: { c: 1 } } }\n *  - Path: ['a', 'b', 'c']\n *  - Result: 1\n *\n * @param object\n * @param path\n * @param fullPath\n * @returns\n */\nfunction getProperty(object: ValueObject, path: string[], fullPath: string) {\n    let curr: (number | string | Function | ValueObject) & { [key: string]: any } = object;\n    let prev: ((number | string | Function | ValueObject) & { [key: string]: any }) | null = null;\n    for (let propName of path) {\n        if (!['object', 'string'].includes(typeof curr)) {\n            throw new Error(`Cannot evaluate ${propName}, property not found (from path ${fullPath})`);\n        }\n        if (typeof curr === 'object' && !(propName in curr)) {\n            throw new Error(`Cannot evaluate ${propName}, property not found (from path ${fullPath})`);\n        }\n        if (typeof curr === 'string' && !curr.hasOwnProperty(propName)) {\n            throw new Error(`Cannot evaluate ${propName}, property not found (from path ${fullPath})`);\n        }\n        prev = curr;\n        curr = curr[propName];\n    }\n\n    if (typeof curr === 'object') {\n        throw new Error('Invalid value');\n    }\n    // If we have a function that is part of an object (e.g. array.includes()), we need to \n    // bind the scope before returning:\n    if (typeof curr === 'function' && prev) {\n        curr = curr.bind(prev);\n    }\n\n    return curr;\n}\n\n/**\n * Evaluates a variable within a formula to its value. The variable value\n * is expected to be given in the evaluate() method or on the formula object.\n */\nclass VariableExpression extends Expression {\n    fullPath: string;\n    varPath: string[];\n    formulaObject: Formula | null;\n\n    constructor(fullPath: string, formulaObj: Formula | null = null) {\n        super();\n        this.formulaObject = formulaObj;\n        this.fullPath = fullPath;\n        this.varPath = fullPath.split('.');\n    }\n\n    evaluate(params = {}): number | string {\n        // params contain variable / value pairs: If this object's variable matches\n        // a varname found in the params, return the value.\n        // eg: params = {x: 5,y:3}, varname = x, return 5\n        // Objects and arrays are also supported:\n        // e.g. params = {x: {y: 5}}, varname = x.y, return 5\n        //  or  params = {x: [2,4,6]}, varname = x.2, return 6\n\n        // Let's look in the value object first:\n        let value = undefined;\n        try {\n            value = getProperty(params, this.varPath, this.fullPath);\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        if (value === undefined) {\n            // Now have a look at the formula object:\n            // This will throw an error if the property is not found:\n            value = getProperty(this.formulaObject ?? {}, this.varPath, this.fullPath);\n        }\n        if (typeof value === 'function' || typeof value === 'object') {\n            throw new Error(`Cannot use ${this.fullPath} as value: It contains a non-numerical value.`);\n        }\n\n        return value;\n    }\n    toString() {\n        return `${this.varPath.join('.')}`;\n    }\n}\n\n/**\n * The Formula class represents a mathematical formula, including functions to evaluate\n * the formula to its final result.\n *\n * Usage example:\n *\n * 1. Create a Formula object instance by passing a formula string:\n * const fObj = new Formula('2^x');\n *\n * 2. evaluate the formula, delivering a value object for each unknown entity:\n * let result = fObj.evaluate({ x: 3 }); // result = 8\n */\nexport default class Formula {\n    [key: string]: any;\n    static Expression = Expression;\n    static BracketExpression = BracketExpression;\n    static PowerExpression = PowerExpression;\n    static MultDivExpression = MultDivExpression;\n    static PlusMinusExpression = PlusMinusExpression;\n    static LogicalExpression = LogicalExpression;\n    static ValueExpression = ValueExpression;\n    static VariableExpression = VariableExpression;\n    static FunctionExpression = FunctionExpression;\n    static MATH_CONSTANTS = MATH_CONSTANTS;\n    static ALLOWED_FUNCTIONS: string[] = ['ifElse'];\n\n    // Create a function blacklist:\n    static functionBlacklist = Object.getOwnPropertyNames(Formula.prototype)\n        .filter((prop) => Formula.prototype[prop] instanceof Function && !this.ALLOWED_FUNCTIONS.includes(prop))\n        .map((prop) => Formula.prototype[prop]);\n\n    public formulaExpression: Expression | null;\n    public options: FormulaOptions;\n    public formulaStr: string;\n    private _variables: string[];\n    private _memory: { [key: string]: number | string };\n\n    /**\n     * Creates a new Formula instance\n     *\n     * Optional configuration can be set in the options object:\n     *\n     * - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     *\n     * @param {String} fStr The formula string, e.g. 'sin(x)/cos(y)'\n     * @param {Object} options An options object. Supported options:\n     *    - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     * @param {Formula} parentFormula Internally used to build a Formula AST\n     */\n    constructor(fStr: string, options: FormulaOptions | null = {}) {\n        this.formulaExpression = null;\n        this.options = { ...{ memoization: false }, ...options };\n        this.formulaStr = '';\n        this._variables = [];\n        this._memory = {};\n        this.setFormula(fStr);\n    }\n\n    /**\n     * Re-sets the given String and parses it to a formula expression. Can be used after initialization,\n     * to re-use the Formula object.\n     *\n     * @param {String} formulaString The formula string to set/parse\n     * @return {this} The Formula object (this)\n     */\n    setFormula(formulaString: string) {\n        if (formulaString) {\n            this.formulaExpression = null;\n            this._variables = [];\n            this._memory = {};\n            this.formulaStr = formulaString;\n            this.formulaExpression = this.parse(formulaString);\n        }\n        return this;\n    }\n\n    /**\n     * Enable memoization: An expression is only evaluated once for the same input.\n     * Further evaluations with the same input will return the in-memory stored result.\n     */\n    enableMemoization() {\n        this.options.memoization = true;\n    }\n\n    /**\n     * Disable in-memory memoization: each call to evaluate() is executed from scratch.\n     */\n    disableMemoization() {\n        this.options.memoization = false;\n        this._memory = {};\n    }\n\n    /**\n     * Splits the given string by ',', makes sure the ',' is not within\n     * a sub-expression\n     * e.g.: str = \"x,pow(3,4)\" returns 2 elements: x and pow(3,4).\n     */\n    splitFunctionParams(toSplit: string) {\n        // do not split on ',' within matching brackets.\n        let pCount = 0,\n            paramStr = '';\n        const params = [];\n        for (let chr of toSplit.split('')) {\n            if (chr === ',' && pCount === 0) {\n                // Found function param, save 'em\n                params.push(paramStr);\n                paramStr = '';\n            } else if (chr === '(') {\n                pCount++;\n                paramStr += chr;\n            } else if (chr === ')') {\n                pCount--;\n                paramStr += chr;\n                if (pCount < 0) {\n                    throw new Error('ERROR: Too many closing parentheses!');\n                }\n            } else {\n                paramStr += chr;\n            }\n        }\n        if (pCount !== 0) {\n            throw new Error('ERROR: Too many opening parentheses!');\n        }\n        if (paramStr.length > 0) {\n            params.push(paramStr);\n        }\n        return params;\n    }\n\n    /**\n     * Cleans the input string from unnecessary whitespace,\n     * and replaces some known constants:\n     */\n    cleanupInputFormula(s: string) {\n        const resParts: string[] = [];\n        const srcParts = s.split('\"');\n        srcParts.forEach((part, index) => {\n            // skip parts marked as string\n            if (index % 2 === 0) {\n                part = part.replace(/[\\s]+/g, '');\n                // surround known math constants with [], to parse them as named variables [xxx]:\n                Object.keys(MATH_CONSTANTS).forEach((c) => {\n                    part = part.replace(new RegExp(`\\\\b${c}\\\\b`, 'g'), `[${c}]`);\n                });\n            }\n            resParts.push(part);\n        });\n        return resParts.join('\"');\n    }\n\n    /**\n     * Parses the given formula string by using a state machine into a single Expression object,\n     * which represents an expression tree (aka AST).\n     *\n     * First, we split the string into 'expression': An expression can be:\n     *   - a number, e.g. '3.45'\n     *   - an unknown variable, e.g. 'x'\n     *   - a single char operator, such as '*','+' etc...\n     *   - a named variable, in [], e.g. [myvar]\n     *   - a function, such as sin(x)\n     *   - a parenthessed expression, containing other expressions\n     *\n     * We want to create an expression tree out of the string. This is done in 2 stages:\n     * 1. form single expressions from the string: parse the string into known expression objects:\n     *   - numbers/[variables]/\"strings\"\n     *   - operators\n     *   - braces (with a sub-expression)\n     *   - functions (with sub-expressions (aka argument expressions))\n     *   This will lead to an array of expressions.\n     *  As an example:\n     *  \"2 + 3 * (4 + 3 ^ 5) * sin(PI * x)\" forms an array of the following expressions:\n     *  `[2, +, 3, *, bracketExpr(4,+,3,^,5), * , functionExpr(PI,*,x)]`\n     * 2. From the raw expression array we form an expression tree by evaluating the expressions in the correct order:\n     *    e.g.:\n     *  the expression array `[2, +, 3, *, bracketExpr(4,+,3,^,5), * , functionExpr(PI,*,x)]` will be transformed into the expression tree:\n     *  ```\n     *         root expr:  (+)\n     *                     / \\\n     *                    2    (*)\n     *                        / \\\n     *                     (*)  functionExpr(...)\n     *                     / \\\n     *                    3   (bracket(..))\n     * ```\n     *\n     * In the end, we have a single root expression node, which then can be evaluated in the evaluate() function.\n     *\n     * @param {String} str The formula string, e.g. '3*sin(PI/x)'\n     * @returns {Expression} An expression object, representing the expression tree\n     */\n    parse(str: string) {\n        // clean the input string first. spaces, math constant replacements etc.:\n        str = this.cleanupInputFormula(str);\n        // start recursive call to parse:\n        return this._do_parse(str);\n    }\n\n    /**\n     * @see parse(): this is the recursive parse function, without the clean string part.\n     * @param {String} str\n     * @returns {Expression} An expression object, representing the expression tree\n     */\n    _do_parse(str: string): Expression {\n        let lastChar = str.length - 1,\n            act = 0,\n            state:\n                | 'initial'\n                | 'within-nr'\n                | 'within-parentheses'\n                | 'within-func-parentheses'\n                | 'within-named-var'\n                | 'within-string'\n                | 'within-expr'\n                | 'within-bracket'\n                | 'within-func'\n                | 'within-logical-operator'\n                | 'invalid' = 'initial',\n            expressions = [],\n            char = '',\n            tmp = '',\n            funcName = null,\n            pCount = 0,\n            pStringDelimiter = '';\n\n        while (act <= lastChar) {\n            switch (state) {\n                case 'initial':\n                    // None state, the beginning. Read a char and see what happens.\n                    char = str.charAt(act);\n                    if (char.match(/[0-9.]/)) {\n                        // found the beginning of a number, change state to \"within-number\"\n                        state = 'within-nr';\n                        tmp = '';\n                        act--;\n                    } else if (this.isOperator(char)) {\n                        // Simple operators. Note: '-' must be treaten specially,\n                        // it could be part of a number.\n                        // it MUST be part of a number if the last found expression\n                        // was an operator (or the beginning):\n                        if (char === '-') {\n                            if (expressions.length === 0 || this.isOperatorExpr(expressions[expressions.length - 1])) {\n                                state = 'within-nr';\n                                tmp = '-';\n                                break;\n                            }\n                        }\n\n                        // Found a simple operator, store as expression:\n                        if (act === lastChar || this.isOperatorExpr(expressions[expressions.length - 1])) {\n                            state = 'invalid'; // invalid to end with an operator, or have 2 operators in conjunction\n                            break;\n                        } else {\n                            expressions.push(\n                                Expression.createOperatorExpression(\n                                    char,\n                                    new PlaceholderExpression(),\n                                    new PlaceholderExpression()\n                                )\n                            );\n                            state = 'initial';\n                        }\n                    } else if (['>', '<', '=', '!'].includes(char)) {\n                        // found the beginning of a logical operator, change state to \"within-logical-operator\"\n                        if (act === lastChar) {\n                            state = 'invalid'; // invalid to end with a logical operator\n                            break;\n                        } else {\n                            state = 'within-logical-operator';\n                            tmp = char;\n                        }\n                    } else if (char === '(') {\n                        // left parenthes found, seems to be the beginning of a new sub-expression:\n                        state = 'within-parentheses';\n                        tmp = '';\n                        pCount = 0;\n                    } else if (char === '[') {\n                        // left named var separator char found, seems to be the beginning of a named var:\n                        state = 'within-named-var';\n                        tmp = '';\n                    } else if (char.match(/[\"']/)) {\n                        // left string separator char found\n                        state = 'within-string';\n                        pStringDelimiter = char;\n                        tmp = '';\n                    } else if (char.match(/[a-zA-Z]/)) {\n                        // multiple chars means it may be a function, else its a var which counts as own expression:\n                        if (act < lastChar && str.charAt(act + 1).match(/[a-zA-Z0-9_.]/)) {\n                            tmp = char;\n                            state = 'within-func';\n                        } else {\n                            // Single variable found:\n                            // We need to check some special considerations:\n                            // - If the last char was a number (e.g. 3x), we need to create a multiplication out of it (3*x)\n                            if (\n                                expressions.length > 0 &&\n                                expressions[expressions.length - 1] instanceof ValueExpression\n                            ) {\n                                expressions.push(\n                                    Expression.createOperatorExpression(\n                                        '*',\n                                        new PlaceholderExpression(),\n                                        new PlaceholderExpression()\n                                    )\n                                );\n                            }\n                            expressions.push(new VariableExpression(char, this));\n                            this.registerVariable(char);\n                            state = 'initial';\n                            tmp = '';\n                        }\n                    }\n                    break;\n                case 'within-nr':\n                    char = str.charAt(act);\n                    if (char.match(/[0-9.]/)) {\n                        //Still within number, store and continue\n                        tmp += char;\n                        if (act === lastChar) {\n                            expressions.push(new ValueExpression(tmp));\n                            state = 'initial';\n                        }\n                    } else {\n                        // Number finished on last round, so add as expression:\n                        if (tmp === '-') {\n                            // just a single '-' means: a variable could follow (e.g. like in 3*-x), we convert it to -1: (3*-1x)\n                            tmp = '-1';\n                        }\n                        expressions.push(new ValueExpression(tmp));\n                        tmp = '';\n                        state = 'initial';\n                        act--;\n                    }\n                    break;\n\n                case 'within-func':\n                    char = str.charAt(act);\n                    if (char.match(/[a-zA-Z0-9_.]/)) {\n                        tmp += char;\n                    } else if (char === '(') {\n                        funcName = tmp;\n                        tmp = '';\n                        pCount = 0;\n                        state = 'within-func-parentheses';\n                    } else {\n                        throw new Error('Wrong character for function at position ' + act);\n                    }\n\n                    break;\n\n                case 'within-named-var':\n                    char = str.charAt(act);\n                    if (char === ']') {\n                        // end of named var, create expression:\n                        expressions.push(new VariableExpression(tmp, this));\n                        this.registerVariable(tmp);\n                        tmp = '';\n                        state = 'initial';\n                    } else if (char.match(/[a-zA-Z0-9_.]/)) {\n                        tmp += char;\n                    } else {\n                        throw new Error('Character not allowed within named variable: ' + char);\n                    }\n                    break;\n\n                case 'within-string':\n                    char = str.charAt(act);\n                    if (char === pStringDelimiter) {\n                        // end of string, create expression:\n                        expressions.push(new ValueExpression(tmp, 'string'));\n                        tmp = '';\n                        state = 'initial';\n                        pStringDelimiter = '';\n                    } else {\n                        tmp += char;\n                    }\n                    break;\n\n                case 'within-parentheses':\n                case 'within-func-parentheses':\n                    char = str.charAt(act);\n                    if (pStringDelimiter) {\n                        // If string is opened, then:\n                        if (char === pStringDelimiter) {\n                            // end of string\n                            pStringDelimiter = '';\n                        }\n                        // accumulate string chars\n                        tmp += char;\n                    } else if (char === ')') {\n                        //Check if this is the matching closing parenthesis.If not, just read ahead.\n                        if (pCount <= 0) {\n                            // Yes, we found the closing parenthesis, create new sub-expression:\n                            if (state === 'within-parentheses') {\n                                expressions.push(new BracketExpression(this._do_parse(tmp)));\n                            } else if (state === 'within-func-parentheses') {\n                                // Function found: create expressions from the inner argument\n                                // string, and create a function expression with it:\n                                let args = this.splitFunctionParams(tmp).map((a) => this._do_parse(a));\n                                expressions.push(new FunctionExpression(funcName, args, this));\n                                funcName = null;\n                            }\n                            state = 'initial';\n                        } else {\n                            pCount--;\n                            tmp += char;\n                        }\n                    } else if (char === '(') {\n                        // begin of a new sub-parenthesis, increase counter:\n                        pCount++;\n                        tmp += char;\n                    } else if (char.match(/[\"']/)) {\n                        // start of string\n                        pStringDelimiter = char;\n                        tmp += char;\n                    } else {\n                        // all other things are just added to the sub-expression:\n                        tmp += char;\n                    }\n                    break;\n\n                case 'within-logical-operator':\n                    char = str.charAt(act);\n                    if (char === '=') {\n                        // the second char of a logical operator\n                        // can only be an equal sign\n                        tmp += char;\n                        act++;\n                    }\n                    // logical operator finished, create expression:\n                    expressions.push(\n                        Expression.createOperatorExpression(\n                            tmp,\n                            new PlaceholderExpression(),\n                            new PlaceholderExpression()\n                        )\n                    );\n                    tmp = '';\n                    state = 'initial';\n                    act--;\n                    break;\n            }\n            act++;\n        }\n\n        if (state !== 'initial') {\n            throw new Error('Could not parse formula: Syntax error.');\n        }\n\n        return this.buildExpressionTree(expressions);\n    }\n\n    /**\n     * @see parse(): Builds an expression tree from the given expression array.\n     * Builds a tree with a single root expression in the correct order of operator precedence.\n     *\n     * Note that the given expression objects are modified and linked.\n     *\n     * @param {*} expressions\n     * @return {Expression} The root Expression of the built expression tree\n     */\n    buildExpressionTree(expressions: Expression[]): Expression {\n        if (expressions.length < 1) {\n            throw new Error('No expression given!');\n        }\n        const exprCopy = [...expressions];\n        let idx = 0;\n        let expr = null;\n        // Replace all Power expressions with a partial tree:\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof PowerExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.base = exprCopy[idx - 1];\n                expr.exponent = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        // Replace all Mult/Div expressions with a partial tree:\n        idx = 0;\n        expr = null;\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof MultDivExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.left = exprCopy[idx - 1];\n                expr.right = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        // Replace all Plus/Minus expressions with a partial tree:\n        idx = 0;\n        expr = null;\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof PlusMinusExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.left = exprCopy[idx - 1];\n                expr.right = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        // Replace all Logical expressions with a partial tree:\n        idx = 0;\n        expr = null;\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof LogicalExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.left = exprCopy[idx - 1];\n                expr.right = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        if (exprCopy.length !== 1) {\n            throw new Error('Could not parse formula: incorrect syntax?');\n        }\n        return exprCopy[0];\n    }\n\n    isOperator(char: string | null) {\n        return typeof char === 'string' && char.match(/[+\\-*/^]/);\n    }\n\n    isOperatorExpr(expr: Expression) {\n        return (\n            expr instanceof PlusMinusExpression ||\n            expr instanceof MultDivExpression ||\n            expr instanceof PowerExpression ||\n            expr instanceof LogicalExpression\n        );\n    }\n\n    registerVariable(varName: string) {\n        if (this._variables.indexOf(varName) < 0) {\n            this._variables.push(varName);\n        }\n    }\n\n    getVariables() {\n        return this._variables;\n    }\n\n    /**\n     * Evaluates a Formula by delivering values for the Formula's variables.\n     * E.g. if the formula is '3*x^2 + 2*x + 4', you should call `evaulate` as follows:\n     *\n     * evaluate({x:2}) --> Result: 20\n     *\n     * @param {ValueObject|Array<ValueObject>} valueObj An object containing values for variables and (unknown) functions,\n     *   or an array of such objects: If an array is given, all objects are evaluated and the results\n     *   also returned as array.\n     * @return {Number|String|(Number|String)[]} The evaluated result, or an array with results\n     */\n    evaluate(valueObj: ValueObject | ValueObject[]): number | string | (number | string)[] {\n        // resolve multiple value objects recursively:\n        if (valueObj instanceof Array) {\n            return valueObj.map((v) => this.evaluate(v)) as (number | string)[];\n        }\n        let expr = this.getExpression();\n        if (!(expr instanceof Expression)) {\n            throw new Error('No expression set: Did you init the object with a Formula?');\n        }\n        if (this.options.memoization) {\n            let res = this.resultFromMemory(valueObj);\n            if (res !== null) {\n                return res;\n            } else {\n                res = expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n                this.storeInMemory(valueObj, res);\n                return res;\n            }\n        }\n        return expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n    }\n\n    hashValues(valueObj: ValueObject) {\n        return JSON.stringify(valueObj);\n    }\n\n    resultFromMemory(valueObj: ValueObject): number | string | null {\n        let key = this.hashValues(valueObj);\n        let res = this._memory[key];\n        if (res !== undefined) {\n            return res;\n        } else {\n            return null;\n        }\n    }\n\n    storeInMemory(valueObj: ValueObject, value: number | string) {\n        this._memory[this.hashValues(valueObj)] = value;\n    }\n\n    getExpression() {\n        return this.formulaExpression;\n    }\n\n    getExpressionString() {\n        return this.formulaExpression ? this.formulaExpression.toString() : '';\n    }\n\n    static calc(formula: string, valueObj: ValueObject | null = null, options = {}) {\n        valueObj = valueObj ?? {};\n        return new Formula(formula, options).evaluate(valueObj);\n    }\n\n    /**\n     * Implements an if/else condition as a function: Checks the predicate\n     * if it evaluates to true-ish (> 0, true, non-empty string, etc.). Returns the trueValue if\n     * the predicate evaluates to true, else the falseValue.\n     * allowed formula functio\n     * @param predicate\n     * @param trueValue\n     * @param falseValue\n     * @returns\n     */\n    ifElse(predicate: number | string | boolean, trueValue: any, falseValue: any): any {\n        if (predicate) {\n            return trueValue;\n        } else {\n            return falseValue;\n        }\n    }\n}\n"],"names":["MATH_CONSTANTS","MathOperatorHelper","value","MathFunctionHelper","Expression","operator","left","right","PowerExpression","MultDivExpression","PlusMinusExpression","LogicalExpression","PlaceholderExpression","params","BracketExpression","expr","__publicField","ValueExpression","type","leftValue","rightValue","base","exponent","baseValue","exponentValue","FunctionExpression","fn","argumentExpressions","formulaObject","_a","paramValues","a","getProperty","e","objFn","mathFn","paramValue","Formula","object","path","fullPath","curr","prev","propName","VariableExpression","formulaObj","_Formula","fStr","options","formulaString","toSplit","pCount","paramStr","chr","s","resParts","part","index","c","str","lastChar","act","state","expressions","char","tmp","funcName","pStringDelimiter","args","exprCopy","idx","varName","valueObj","v","res","key","formula","predicate","trueValue","falseValue","prop"],"mappings":"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"}