{"version":3,"file":"fparser.js","sources":["../src/helpers.ts","../src/math_function_helper.ts","../src/math_operator_helper.ts","../src/expression.ts","../src/tokenizer.ts","../src/parser.ts","../src/fparser.ts"],"sourcesContent":["\n/**\n * accesses an object's property by evaluating the given path.\n *\n * Example:\n *  - Object: { a: { b: { c: 1 } } }\n *  - Path: ['a', 'b', 'c']\n *  - Result: 1\n *\n * @param object\n * @param path\n * @param fullPath\n * @returns\n */\nexport function getProperty(object: ValueObject, path: string[], fullPath: string) {\n    let curr: (number | string | Function | Object) & { [key: string]: any } = object;\n    let prev: ((number | string | Function | Object) & { [key: string]: any }) | null = null;\n    for (let propName of path) {\n        if (!['object', 'string'].includes(typeof curr)) {\n            throw new Error(`Cannot evaluate ${propName}, property not found (from path ${fullPath})`);\n        }\n        if (typeof curr === 'object' && !(propName in curr)) {\n            throw new Error(`Cannot evaluate ${propName}, property not found (from path ${fullPath})`);\n        }\n        if (typeof curr === 'string' && !curr.hasOwnProperty(propName)) {\n            throw new Error(`Cannot evaluate ${propName}, property not found (from path ${fullPath})`);\n        }\n        prev = curr;\n        curr = curr[propName];\n    }\n\n    if (typeof curr === 'object' && !(curr instanceof Array)) {\n        throw new Error('Invalid value');\n    }\n    // If we have a function that is part of an object (e.g. array.includes()), we need to\n    // bind the scope before returning:\n    if (typeof curr === 'function' && prev) {\n        curr = curr.bind(prev);\n    }\n\n    return curr;\n}","\nexport class MathFunctionHelper {\n    static throwIfNotNumber(value: number | string) {\n        const valueType = typeof value;\n        if (valueType === 'string') {\n            throw new Error('Strings are not allowed in math operations');\n        }\n    }\n}\n","export class MathOperatorHelper {\n    static throwIfNotNumber(value: number | string) {\n        const valueType = typeof value;\n        if (valueType === 'string') {\n            throw new Error('Strings are not allowed in math operations');\n        }\n    }\n}\n","import Formula from \"./fparser\";\nimport { getProperty } from \"./helpers\";\nimport { MathFunctionHelper } from \"./math_function_helper\";\nimport { MathOperatorHelper } from \"./math_operator_helper\";\nimport type { Token } from \"./tokenizer\";\n\n/**\n * Base class for all expressions: An Expression is somethint that eventually evaluates to a\n * final value, like a number, or a string. It can be composed of other expressions, which\n * are evaluated recursively until a final value is reached.\n */\nexport abstract class Expression {\n    /**\n     * Creates an operator expression from a token.\n     * @param operatorToken The operator token (or string for backward compatibility)\n     * @param left Left operand expression\n     * @param right Right operand expression\n     */\n    static createOperatorExpression(\n        operatorToken: Token | string,\n        left: Expression,\n        right: Expression\n    ) {\n        // Extract operator string from token or use directly if it's a string (backward compatibility)\n        const operator = typeof operatorToken === 'string' ? operatorToken : String(operatorToken.value);\n\n        if (operator === '^') {\n            return new PowerExpression(left, right);\n        }\n        if (['*', '/'].includes(operator)) {\n            return new MultDivExpression(operator, left, right);\n        }\n        if (['+', '-'].includes(operator)) {\n            return new PlusMinusExpression(operator, left, right);\n        }\n        if (['<', '>', '<=', '>=', '=', '!='].includes(operator)) {\n            return new LogicalExpression(operator, left, right);\n        }\n        throw new Error(`Unknown operator: ${operator}`);\n    }\n\n    abstract evaluate(params: ValueObject): number | string;\n\n    toString() {\n        return '';\n    }\n}\n\n/**\n * An unused expression - it is only used during parsing stage, to store a placeholder for a\n * real expression later.\n */\nexport class PlaceholderExpression extends Expression {\n    evaluate(params: ValueObject): number | string {\n        throw new Error('PlaceholderExpression cannot be evaluated');\n    }\n    toString() {\n        return '[placeholder]';\n    }\n}\n\n/**\n * Represents a bracketed expression: (expr)\n * It evaluates its inner expression.\n */\nexport class BracketExpression extends Expression {\n    innerExpression: Expression;\n\n    constructor(expr: Expression) {\n        super();\n        this.innerExpression = expr;\n        if (!(this.innerExpression instanceof Expression)) {\n            throw new Error('No inner expression given for bracket expression');\n        }\n    }\n    evaluate(params = {}): number | string {\n        return this.innerExpression.evaluate(params);\n    }\n    toString() {\n        return `(${this.innerExpression.toString()})`;\n    }\n}\n\n/**\n * Represents a final value, e.g. a number.\n */\nexport class ValueExpression extends Expression {\n    value: number | string;\n    type: string;\n\n    constructor(value: number | string, type: string = 'number') {\n        super();\n        this.value = Number(value);\n        switch (type) {\n            case 'number':\n                this.value = Number(value);\n                if (isNaN(this.value)) {\n                    throw new Error('Cannot parse number: ' + value);\n                }\n                break;\n            case 'string':\n                this.value = String(value);\n                break;\n            default:\n                throw new Error('Invalid value type: ' + type);\n        }\n        this.type = type;\n    }\n    evaluate(): number | string {\n        return this.value;\n    }\n    toString() {\n        switch (this.type) {\n            case 'number':\n                return String(this.value);\n            case 'string':\n                return String('\"' + this.value + '\"');\n            default:\n                throw new Error('Invalid type');\n        }\n    }\n}\n\n/**\n * Represents the '+' or '-' operator expression:\n * it evaluates its left and right expression and returns the sum / difference of the result\n */\nexport class PlusMinusExpression extends Expression {\n    static PLUS = '+';\n    static MINUS = '-';\n\n    operator: string;\n    left: Expression;\n    right: Expression;\n\n    constructor(operator: string, left: Expression, right: Expression) {\n        super();\n        if (!['+', '-'].includes(operator)) {\n            throw new Error(`Operator not allowed in Plus/Minus expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const leftValue = this.left.evaluate(params);\n        const rightValue = this.right.evaluate(params);\n        MathOperatorHelper.throwIfNotNumber(leftValue);\n        MathOperatorHelper.throwIfNotNumber(rightValue);\n        if (this.operator === '+') {\n            return Number(leftValue) + Number(rightValue);\n        }\n        if (this.operator === '-') {\n            return Number(leftValue) - Number(rightValue);\n        }\n        throw new Error('Unknown operator for PlusMinus expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\n/**\n * Represents the '*' or '/' operator expression:\n * it evaluates its left and right expression and returns the product / division of the two.\n */\nexport class MultDivExpression extends Expression {\n    static MULT = '*';\n    static DIV = '/';\n\n    operator: string;\n    left: Expression;\n    right: Expression;\n\n    constructor(operator: string, left: Expression, right: Expression) {\n        super();\n        if (!['*', '/'].includes(operator)) {\n            throw new Error(`Operator not allowed in Multiply/Division expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const leftValue = this.left.evaluate(params);\n        const rightValue = this.right.evaluate(params);\n        MathOperatorHelper.throwIfNotNumber(leftValue);\n        MathOperatorHelper.throwIfNotNumber(rightValue);\n        if (this.operator === '*') {\n            return Number(leftValue) * Number(rightValue);\n        }\n        if (this.operator === '/') {\n            return Number(leftValue) / Number(rightValue);\n        }\n        throw new Error('Unknown operator for MultDiv expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\n/**\n * Represents the 'power of' operator expression:\n * evaluates base^exponent.\n */\nexport class PowerExpression extends Expression {\n    base: Expression;\n    exponent: Expression;\n\n    constructor(base: Expression, exponent: Expression) {\n        super();\n        this.base = base;\n        this.exponent = exponent;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const baseValue = this.base.evaluate(params);\n        const exponentValue = this.exponent.evaluate(params);\n        MathOperatorHelper.throwIfNotNumber(baseValue);\n        MathOperatorHelper.throwIfNotNumber(exponentValue);\n\n        return Math.pow(Number(baseValue), Number(exponentValue));\n    }\n\n    toString() {\n        return `${this.base.toString()}^${this.exponent.toString()}`;\n    }\n}\n\n/**\n * Represents locical operator expressions: All logical operations\n * evaluate either to 0 or 1 (false or true): this way, you can use them in calculations\n * to enable / disable different parts of the formula.\n */\nexport class LogicalExpression extends Expression {\n    static LT = '<';\n    static GT = '>';\n    static LTE = '<=';\n    static GTE = '>=';\n    static EQ = '=';\n    static NEQ = '!=';\n\n    operator: string;\n    left: Expression;\n    right: Expression;\n\n    constructor(operator: string, left: Expression, right: Expression) {\n        super();\n        if (!['<', '>', '<=', '>=', '=', '!='].includes(operator)) {\n            throw new Error(`Operator not allowed in Logical expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params: ValueObject = {}): number {\n        const leftValue = this.left.evaluate(params);\n        const rightValue = this.right.evaluate(params);\n        switch (this.operator) {\n            case '<':\n                return leftValue < rightValue ? 1 : 0;\n            case '>':\n                return leftValue > rightValue ? 1 : 0;\n            case '<=':\n                return leftValue <= rightValue ? 1 : 0;\n            case '>=':\n                return leftValue >= rightValue ? 1 : 0;\n            case '=':\n                return leftValue === rightValue ? 1 : 0;\n            case '!=':\n                return leftValue !== rightValue ? 1 : 0;\n        }\n        throw new Error('Unknown operator for Logical expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\n/**\n * Represents a function expression: evaluates the expression in the function arguments,\n * then executes the function with the evaluated arguments, an evaluates the result.\n */\nexport class FunctionExpression extends Expression {\n    fn: string;\n    varPath: string[];\n    argumentExpressions: Expression[];\n    formulaObject: Formula | null;\n    blacklisted: boolean | undefined;\n\n    constructor(fn: string | null, argumentExpressions: Expression[], formulaObject: Formula | null = null) {\n        super();\n        this.fn = fn ?? '';\n        this.varPath = this.fn.split('.');\n        this.argumentExpressions = argumentExpressions || [];\n        this.formulaObject = formulaObject;\n        this.blacklisted = undefined;\n    }\n\n    evaluate(params: ValueObject = {}): number | string {\n        params = params || {};\n        const paramValues = this.argumentExpressions.map((a) => a.evaluate(params));\n\n        // If the params object itself has a function definition with\n        // the function name, call this one:\n        // let fn = params[this.fn];\n        try {\n            let fn = getProperty(params, this.varPath, this.fn);\n            if (fn instanceof Function) {\n                return fn.apply(this, paramValues);\n            }\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n\n        let objFn;\n        try {\n            // perhaps the Formula object has the function? so call it:\n            objFn = getProperty(this.formulaObject ?? {}, this.varPath, this.fn);\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        if (this.formulaObject && objFn instanceof Function) {\n            // Don't, if it is blacklisted:\n            if (this.isBlacklisted()) {\n                throw new Error('Blacklisted function called: ' + this.fn);\n            }\n            return objFn.apply(this.formulaObject, paramValues);\n        }\n\n        try {\n            // Has the JS Math object a function as requested? Call it:\n            const mathFn = getProperty(Math, this.varPath, this.fn);\n            if (mathFn instanceof Function) {\n                paramValues.forEach((paramValue) => {\n                    MathFunctionHelper.throwIfNotNumber(paramValue);\n                });\n\n                return mathFn.apply(this, paramValues);\n            }\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        // No more options left: sorry!\n        throw new Error('Function not found: ' + this.fn);\n    }\n\n    toString() {\n        return `${this.fn}(${this.argumentExpressions.map((a) => a.toString()).join(', ')})`;\n    }\n\n    isBlacklisted() {\n        // cache evaluation of blacklisted function, to save call time:\n        if (this.blacklisted === undefined) {\n            this.blacklisted = Formula.functionBlacklist.includes(\n                this.formulaObject ? this.formulaObject[this.fn] : null\n            );\n        }\n        return this.blacklisted;\n    }\n}\n\nexport class VariableExpression extends Expression {\n    fullPath: string;\n    varPath: string[];\n    formulaObject: Formula | null;\n\n    constructor(fullPath: string, formulaObj: Formula | null = null) {\n        super();\n        this.formulaObject = formulaObj;\n        this.fullPath = fullPath;\n        this.varPath = fullPath.split('.');\n    }\n\n    evaluate(params = {}): number | string {\n        // params contain variable / value pairs: If this object's variable matches\n        // a varname found in the params, return the value.\n        // eg: params = {x: 5,y:3}, varname = x, return 5\n        // Objects and arrays are also supported:\n        // e.g. params = {x: {y: 5}}, varname = x.y, return 5\n        //  or  params = {x: [2,4,6]}, varname = x.2, return 6\n\n        // Let's look in the value object first:\n        let value = undefined;\n        try {\n            value = getProperty(params, this.varPath, this.fullPath);\n        } catch (e) {\n            // pass: getProperty has found nothing, which throws an error, but\n            // we need to continue\n        }\n        if (value === undefined) {\n            // Now have a look at the formula object:\n            // This will throw an error if the property is not found:\n            value = getProperty(this.formulaObject ?? {}, this.varPath, this.fullPath);\n        }\n        if (typeof value === 'function' || typeof value === 'object') {\n            throw new Error(`Cannot use ${this.fullPath} as value: It contains a non-numerical value.`);\n        }\n\n        return value;\n    }\n    toString() {\n        return `${this.varPath.join('.')}`;\n    }\n}","/**\n * Tokenizer for Formula Parser\n * Converts a formula string into a stream of tokens\n */\n\nexport enum TokenType {\n    NUMBER = 'NUMBER',\n    VARIABLE = 'VARIABLE',\n    OPERATOR = 'OPERATOR',\n    LOGICAL_OPERATOR = 'LOGICAL_OPERATOR',\n    FUNCTION = 'FUNCTION',\n    LEFT_PAREN = 'LEFT_PAREN',\n    RIGHT_PAREN = 'RIGHT_PAREN',\n    COMMA = 'COMMA',\n    STRING = 'STRING',\n    EOF = 'EOF'\n}\n\nexport interface Token {\n    type: TokenType;\n    value: string | number;\n    raw: string;           // original text from input\n    position: number;      // character position in input\n    length: number;        // length of the token in original input\n}\n\nexport class Tokenizer {\n    private input: string;\n    private position: number;\n\n    constructor() {\n        this.input = '';\n        this.position = 0;\n    }\n\n    tokenize(input: string): Token[] {\n        this.input = input;\n        this.position = 0;\n        const tokens: Token[] = [];\n\n        while (this.position < this.input.length) {\n            this.skipWhitespace();\n\n            if (this.position >= this.input.length) break;\n\n            const token = this.nextToken(tokens);\n            if (token) {\n                tokens.push(token);\n            }\n        }\n\n        tokens.push({\n            type: TokenType.EOF,\n            value: '',\n            raw: '',\n            position: this.position,\n            length: 0\n        });\n        return tokens;\n    }\n\n    private nextToken(tokens: Token[]): Token | null {\n        // Try each token pattern in order\n        // String must be checked first to avoid conflicts\n        return (\n            this.readString() ||\n            this.readLogicalOperator() ||\n            this.readNumber(tokens) ||\n            this.readOperator() ||\n            this.readParenthesis() ||\n            this.readComma() ||\n            this.readIdentifier() ||\n            this.throwUnexpectedChar()\n        );\n    }\n\n    private skipWhitespace(): void {\n        while (this.position < this.input.length && /\\s/.test(this.input[this.position])) {\n            this.position++;\n        }\n    }\n\n    private peek(offset: number = 0): string {\n        return this.input[this.position + offset] || '';\n    }\n\n    /**\n     * Read a number token. Includes the minus sign if it's unambiguously part of the number.\n     * Handles negative numbers when preceded by operators, commas, left parenthesis, or at start.\n     */\n    private readNumber(tokens: Token[]): Token | null {\n        const start = this.position;\n        let raw = '';\n\n        // Check for negative sign\n        if (this.peek() === '-') {\n            // Include '-' as part of the number only if:\n            // 1. It's at the start (no previous token)\n            // 2. Previous token is an operator (not a number or variable or closing paren)\n            // 3. Previous token is a comma\n            // 4. Previous token is a left parenthesis\n            const prevToken = tokens.length > 0 ? tokens[tokens.length - 1] : null;\n            const canBeNegative =\n                !prevToken ||\n                prevToken.type === TokenType.OPERATOR ||\n                prevToken.type === TokenType.LOGICAL_OPERATOR ||\n                prevToken.type === TokenType.COMMA ||\n                prevToken.type === TokenType.LEFT_PAREN;\n\n            if (canBeNegative && /\\d/.test(this.peek(1))) {\n                raw += this.peek();\n                this.position++;\n            } else {\n                return null; // Not a number, it's a minus operator\n            }\n        }\n\n        // Read digits before decimal point\n        if (!/\\d/.test(this.peek())) {\n            // If we consumed a '-' but there's no digit, backtrack\n            if (raw === '-') {\n                this.position = start;\n                return null;\n            }\n            return null;\n        }\n\n        while (/\\d/.test(this.peek())) {\n            raw += this.peek();\n            this.position++;\n        }\n\n        // Read decimal point and digits after\n        if (this.peek() === '.') {\n            raw += this.peek();\n            this.position++;\n\n            while (/\\d/.test(this.peek())) {\n                raw += this.peek();\n                this.position++;\n            }\n        }\n\n        const value = parseFloat(raw);\n\n        return {\n            type: TokenType.NUMBER,\n            value: value,\n            raw: raw,\n            position: start,\n            length: this.position - start\n        };\n    }\n\n    /**\n     * Read an identifier (variable or function name).\n     * Supports: myVar, x, PI, my_var, obj.prop, [myVar], [obj.prop]\n     */\n    private readIdentifier(): Token | null {\n        const start = this.position;\n        let raw = '';\n        let value = '';\n        let isBracketed = false;\n\n        // Check for bracketed variable [varname]\n        if (this.peek() === '[') {\n            isBracketed = true;\n            raw += this.peek();\n            this.position++;\n\n            // Read until closing bracket\n            while (this.position < this.input.length && this.peek() !== ']') {\n                if (!/[a-zA-Z0-9_.]/.test(this.peek())) {\n                    throw new Error(\n                        `Invalid character '${this.peek()}' in bracketed variable at position ${this.position}`\n                    );\n                }\n                value += this.peek();\n                raw += this.peek();\n                this.position++;\n            }\n\n            if (this.peek() !== ']') {\n                throw new Error(`Unclosed bracket for variable at position ${start}`);\n            }\n\n            raw += this.peek();\n            this.position++; // consume ']'\n        } else {\n            // Regular identifier\n            if (!/[a-zA-Z_]/.test(this.peek())) {\n                return null;\n            }\n\n            while (/[a-zA-Z0-9_.]/.test(this.peek())) {\n                value += this.peek();\n                raw += this.peek();\n                this.position++;\n            }\n        }\n\n        if (value === '') {\n            if (isBracketed) {\n                throw new Error(`Empty bracketed variable at position ${start}`);\n            }\n            return null;\n        }\n\n        // Look ahead to determine if this is a function call\n        let savedPos = this.position;\n        this.skipWhitespace();\n        const isFunction = this.peek() === '(';\n        this.position = savedPos; // restore position (whitespace will be skipped in main loop)\n\n        return {\n            type: isFunction ? TokenType.FUNCTION : TokenType.VARIABLE,\n            value: value,\n            raw: raw,\n            position: start,\n            length: this.position - start\n        };\n    }\n\n    /**\n     * Read a string literal (single or double quoted).\n     * Supports escaped quotes: \\\" or \\'\n     */\n    private readString(): Token | null {\n        const start = this.position;\n        const quote = this.peek();\n\n        if (quote !== '\"' && quote !== \"'\") {\n            return null;\n        }\n\n        let raw = quote;\n        let value = '';\n        this.position++; // consume opening quote\n\n        while (this.position < this.input.length) {\n            const char = this.peek();\n\n            if (char === '\\\\' && (this.peek(1) === quote || this.peek(1) === '\\\\')) {\n                // Escaped quote or backslash\n                const escapedChar = this.peek(1);\n                raw += char + escapedChar;\n                value += escapedChar;\n                this.position += 2;\n            } else if (char === quote) {\n                // Closing quote\n                raw += char;\n                this.position++;\n                break;\n            } else {\n                raw += char;\n                value += char;\n                this.position++;\n            }\n        }\n\n        if (!raw.endsWith(quote)) {\n            throw new Error(`Unterminated string at position ${start}`);\n        }\n\n        return {\n            type: TokenType.STRING,\n            value: value,\n            raw: raw,\n            position: start,\n            length: this.position - start\n        };\n    }\n\n    /**\n     * Read a simple operator: +, -, *, /, ^\n     */\n    private readOperator(): Token | null {\n        const char = this.peek();\n        const operatorPattern = /[+\\-*/^]/;\n\n        if (!operatorPattern.test(char)) {\n            return null;\n        }\n\n        const start = this.position;\n        this.position++;\n\n        return {\n            type: TokenType.OPERATOR,\n            value: char,\n            raw: char,\n            position: start,\n            length: 1\n        };\n    }\n\n    /**\n     * Read a logical operator: <, >, <=, >=, =, !=\n     */\n    private readLogicalOperator(): Token | null {\n        const start = this.position;\n        const char = this.peek();\n        const nextChar = this.peek(1);\n\n        // Two-character logical operators\n        if (\n            (char === '<' && nextChar === '=') ||\n            (char === '>' && nextChar === '=') ||\n            (char === '!' && nextChar === '=')\n        ) {\n            const raw = char + nextChar;\n            this.position += 2;\n            return {\n                type: TokenType.LOGICAL_OPERATOR,\n                value: raw,\n                raw: raw,\n                position: start,\n                length: 2\n            };\n        }\n\n        // Single-character logical operators\n        if (char === '<' || char === '>' || char === '=') {\n            this.position++;\n            return {\n                type: TokenType.LOGICAL_OPERATOR,\n                value: char,\n                raw: char,\n                position: start,\n                length: 1\n            };\n        }\n\n        // '!' by itself is not valid (only != is valid)\n        if (char === '!') {\n            throw new Error(`Invalid operator '!' at position ${start}. Did you mean '!='?`);\n        }\n\n        return null;\n    }\n\n    /**\n     * Read parentheses\n     */\n    private readParenthesis(): Token | null {\n        const char = this.peek();\n        const start = this.position;\n\n        if (char === '(') {\n            this.position++;\n            return {\n                type: TokenType.LEFT_PAREN,\n                value: '(',\n                raw: '(',\n                position: start,\n                length: 1\n            };\n        }\n\n        if (char === ')') {\n            this.position++;\n            return {\n                type: TokenType.RIGHT_PAREN,\n                value: ')',\n                raw: ')',\n                position: start,\n                length: 1\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * Read comma separator\n     */\n    private readComma(): Token | null {\n        const char = this.peek();\n        const start = this.position;\n\n        if (char === ',') {\n            this.position++;\n            return {\n                type: TokenType.COMMA,\n                value: ',',\n                raw: ',',\n                position: start,\n                length: 1\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * Throw an error for unexpected characters\n     */\n    private throwUnexpectedChar(): never {\n        const char = this.peek();\n        throw new Error(`Unexpected character '${char}' at position ${this.position}`);\n    }\n}\n","/**\n * Parser for Formula Parser\n * Converts a stream of tokens into an Abstract Syntax Tree (AST)\n * Uses Pratt parsing algorithm for operator precedence\n */\n\nimport { Token, TokenType } from './tokenizer';\nimport {\n    Expression,\n    BracketExpression,\n    ValueExpression,\n    VariableExpression,\n    FunctionExpression,\n    MultDivExpression\n} from './expression';\nimport Formula from './fparser';\n\n/**\n * Operator precedence levels (higher = tighter binding)\n */\nconst PRECEDENCE = {\n    // Logical operators (lowest precedence)\n    '=': 1,\n    '!=': 1,\n    '<': 1,\n    '>': 1,\n    '<=': 1,\n    '>=': 1,\n\n    // Addition/Subtraction\n    '+': 2,\n    '-': 2,\n\n    // Multiplication/Division\n    '*': 3,\n    '/': 3,\n\n    // Power (highest precedence, right-associative)\n    '^': 4\n};\n\n/**\n * Parser class that builds an AST from tokens\n */\nexport class Parser {\n    private tokens: Token[];\n    private current: number;\n    private formulaObject: Formula;\n\n    constructor(tokens: Token[], formulaObject: Formula) {\n        this.tokens = tokens;\n        this.current = 0;\n        this.formulaObject = formulaObject;\n    }\n\n    /**\n     * Main entry point: Parse the token stream into an Expression tree\n     */\n    parse(): Expression {\n        const expr = this.parseExpression(0);\n        if (!this.isAtEnd()) {\n            const token = this.peek();\n            throw new Error(\n                `Unexpected token '${token.value}' at position ${token.position}: Expected end of expression`\n            );\n        }\n        return expr;\n    }\n\n    /**\n     * Pratt parsing: handles operator precedence elegantly\n     * @param minPrecedence Minimum precedence level to parse\n     */\n    private parseExpression(minPrecedence: number): Expression {\n        let left = this.parsePrimary();\n\n        while (!this.isAtEnd()) {\n            const token = this.peek();\n\n            // Stop if we hit a non-operator token (parenthesis, comma, etc.)\n            if (token.type !== TokenType.OPERATOR && token.type !== TokenType.LOGICAL_OPERATOR) {\n                break;\n            }\n\n            const precedence = this.getPrecedence(token);\n\n            if (precedence < minPrecedence) break;\n\n            // Handle right-associative operators (power)\n            const isRightAssociative = token.value === '^';\n            const nextPrecedence = isRightAssociative ? precedence : precedence + 1;\n\n            this.consume();\n            const right = this.parseExpression(nextPrecedence);\n\n            left = Expression.createOperatorExpression(\n                token,\n                left,\n                right\n            );\n        }\n\n        return left;\n    }\n\n    /**\n     * Parse primary expressions: numbers, variables, functions, parentheses, unary operators\n     */\n    private parsePrimary(): Expression {\n        const token = this.peek();\n\n        // Handle unary minus: convert to -1 * expr\n        if (this.match(TokenType.OPERATOR) && token.value === '-') {\n            this.consume();\n            const expr = this.parsePrimary();\n            return new MultDivExpression('*', new ValueExpression(-1), expr);\n        }\n\n        // Handle unary plus: just skip it\n        if (this.match(TokenType.OPERATOR) && token.value === '+') {\n            this.consume();\n            return this.parsePrimary();\n        }\n\n        // Numbers\n        if (this.match(TokenType.NUMBER)) {\n            this.consume();\n            return new ValueExpression(token.value);\n        }\n\n        // Strings\n        if (this.match(TokenType.STRING)) {\n            this.consume();\n            return new ValueExpression(token.value, 'string');\n        }\n\n        // Parenthesized expressions\n        if (this.match(TokenType.LEFT_PAREN)) {\n            return this.parseParenthesizedExpression();\n        }\n\n        // Variables or Functions\n        if (this.match(TokenType.VARIABLE, TokenType.FUNCTION)) {\n            return this.parseVariableOrFunction();\n        }\n\n        throw new Error(\n            `Unexpected token '${token.value}' at position ${token.position}: Expected number, variable, function, or '('`\n        );\n    }\n\n    /**\n     * Parse a parenthesized expression: (expr)\n     */\n    private parseParenthesizedExpression(): Expression {\n        const leftParen = this.consume(TokenType.LEFT_PAREN);\n        const expr = this.parseExpression(0);\n\n        if (!this.match(TokenType.RIGHT_PAREN)) {\n            const token = this.peek();\n            throw new Error(\n                `Missing closing parenthesis at position ${token.position}: Expected ')' to match '(' at position ${leftParen.position}`\n            );\n        }\n\n        this.consume(TokenType.RIGHT_PAREN);\n        return new BracketExpression(expr);\n    }\n\n    /**\n     * Parse a variable or function call\n     */\n    private parseVariableOrFunction(): Expression {\n        const token = this.consume();\n        const name = token.value as string;\n\n        // Check if it's a function call (next token is '(')\n        if (this.match(TokenType.LEFT_PAREN)) {\n            return this.parseFunctionCall(name, token.position);\n        }\n\n        // It's a variable\n        this.formulaObject.registerVariable(name);\n        return new VariableExpression(name, this.formulaObject);\n    }\n\n    /**\n     * Parse a function call: functionName(arg1, arg2, ...)\n     */\n    private parseFunctionCall(name: string, namePosition: number): Expression {\n        const leftParen = this.consume(TokenType.LEFT_PAREN);\n        const args: Expression[] = [];\n\n        // Parse arguments (if any)\n        if (!this.match(TokenType.RIGHT_PAREN)) {\n            do {\n                args.push(this.parseExpression(0));\n            } while (this.matchAndConsume(TokenType.COMMA));\n        }\n\n        if (!this.match(TokenType.RIGHT_PAREN)) {\n            const token = this.peek();\n            throw new Error(\n                `Missing closing parenthesis for function '${name}' at position ${token.position}: Expected ')' to match '(' at position ${leftParen.position}`\n            );\n        }\n\n        this.consume(TokenType.RIGHT_PAREN);\n        return new FunctionExpression(name, args, this.formulaObject);\n    }\n\n    // ==================== Helper Methods ====================\n\n    /**\n     * Get the current token without consuming it\n     */\n    private peek(): Token {\n        return this.tokens[this.current];\n    }\n\n    /**\n     * Consume the current token and move to the next one\n     * @param expected Optional: throw error if current token is not of this type\n     */\n    private consume(expected?: TokenType): Token {\n        const token = this.peek();\n        if (expected && token.type !== expected) {\n            throw new Error(\n                `Expected ${expected} at position ${token.position}, got ${token.type} ('${token.value}')`\n            );\n        }\n        this.current++;\n        return token;\n    }\n\n    /**\n     * Check if the current token matches any of the given types\n     */\n    private match(...types: TokenType[]): boolean {\n        return types.includes(this.peek().type);\n    }\n\n    /**\n     * If the current token matches the given type, consume it and return true\n     */\n    private matchAndConsume(type: TokenType): boolean {\n        if (this.match(type)) {\n            this.consume();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Check if we've reached the end of the token stream\n     */\n    private isAtEnd(): boolean {\n        return this.peek().type === TokenType.EOF;\n    }\n\n    /**\n     * Get the precedence level for a token\n     */\n    private getPrecedence(token: Token): number {\n        if (token.type === TokenType.LOGICAL_OPERATOR) {\n            const op = token.value as string;\n            return PRECEDENCE[op as keyof typeof PRECEDENCE] ?? 0;\n        }\n        if (token.type === TokenType.OPERATOR) {\n            const op = token.value as string;\n            return PRECEDENCE[op as keyof typeof PRECEDENCE] ?? 0;\n        }\n        return 0;\n    }\n}\n","import {\n    BracketExpression,\n    Expression,\n    FunctionExpression,\n    LogicalExpression,\n    MultDivExpression,\n    PlaceholderExpression,\n    PlusMinusExpression,\n    PowerExpression,\n    ValueExpression,\n    VariableExpression\n} from './expression';\n\nexport { Tokenizer, TokenType } from './tokenizer';\nexport type { Token } from './tokenizer';\nexport { Parser } from './parser';\n\n/**\n * JS Formula Parser\n * -------------------\n * (c) 2012-2024 Alexander Schenkel, alex@alexi.ch\n *\n * JS Formula Parser takes a string, parses its mathmatical formula\n * and creates an evaluatable Formula object of it.\n *\n * Example input:\n *\n * var fObj = new Formula('sin(PI*x)/(2*PI)');\n * var result = fObj.evaluate({x: 2});\n * var results = fObj.evaluate([\n *     {x: 2},\n *     {x: 4},\n *     {x: 8}\n * ]);\n *\n * LICENSE:\n * -------------\n * MIT license, see LICENSE file\n */\nconst MATH_CONSTANTS = {\n    PI: Math.PI,\n    E: Math.E,\n    LN2: Math.LN2,\n    LN10: Math.LN10,\n    LOG2E: Math.LOG2E,\n    LOG10E: Math.LOG10E,\n    SQRT1_2: Math.SQRT1_2,\n    SQRT2: Math.SQRT2\n};\n\ndeclare global {\n    interface Math {\n        [key: string]: number | Function;\n    }\n}\n\n/**\n * Evaluates a variable within a formula to its value. The variable value\n * is expected to be given in the evaluate() method or on the formula object.\n */\n\n/**\n * The Formula class represents a mathematical formula, including functions to evaluate\n * the formula to its final result.\n *\n * Usage example:\n *\n * 1. Create a Formula object instance by passing a formula string:\n * const fObj = new Formula('2^x');\n *\n * 2. evaluate the formula, delivering a value object for each unknown entity:\n * let result = fObj.evaluate({ x: 3 }); // result = 8\n */\nexport default class Formula {\n    [key: string]: any;\n    static Expression = Expression;\n    static BracketExpression = BracketExpression;\n    static PowerExpression = PowerExpression;\n    static MultDivExpression = MultDivExpression;\n    static PlusMinusExpression = PlusMinusExpression;\n    static LogicalExpression = LogicalExpression;\n    static ValueExpression = ValueExpression;\n    static VariableExpression = VariableExpression;\n    static FunctionExpression = FunctionExpression;\n    static MATH_CONSTANTS = MATH_CONSTANTS;\n    static ALLOWED_FUNCTIONS: string[] = ['ifElse', 'first'];\n\n    // Create a function blacklist:\n    static functionBlacklist = Object.getOwnPropertyNames(Formula.prototype)\n        .filter((prop) => Formula.prototype[prop] instanceof Function && !this.ALLOWED_FUNCTIONS.includes(prop))\n        .map((prop) => Formula.prototype[prop]);\n\n    public formulaExpression: Expression | null;\n    public options: FormulaOptions;\n    public formulaStr: string;\n    private _variables: string[];\n    private _memory: { [key: string]: number | string };\n\n    /**\n     * Creates a new Formula instance\n     *\n     * Optional configuration can be set in the options object:\n     *\n     * - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     *\n     * @param {String} fStr The formula string, e.g. 'sin(x)/cos(y)'\n     * @param {Object} options An options object. Supported options:\n     *    - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     * @param {Formula} parentFormula Internally used to build a Formula AST\n     */\n    constructor(fStr: string, options: FormulaOptions | null = {}) {\n        this.formulaExpression = null;\n        this.options = { ...{ memoization: false }, ...options };\n        this.formulaStr = '';\n        this._variables = [];\n        this._memory = {};\n        this.setFormula(fStr);\n    }\n\n    /**\n     * Re-sets the given String and parses it to a formula expression. Can be used after initialization,\n     * to re-use the Formula object.\n     *\n     * @param {String} formulaString The formula string to set/parse\n     * @return {this} The Formula object (this)\n     */\n    setFormula(formulaString: string) {\n        if (formulaString) {\n            this.formulaExpression = null;\n            this._variables = [];\n            this._memory = {};\n            this.formulaStr = formulaString;\n            this.formulaExpression = this.parse(formulaString);\n        }\n        return this;\n    }\n\n    /**\n     * Enable memoization: An expression is only evaluated once for the same input.\n     * Further evaluations with the same input will return the in-memory stored result.\n     */\n    enableMemoization() {\n        this.options.memoization = true;\n    }\n\n    /**\n     * Disable in-memory memoization: each call to evaluate() is executed from scratch.\n     */\n    disableMemoization() {\n        this.options.memoization = false;\n        this._memory = {};\n    }\n\n    /**\n     * Splits the given string by ',', makes sure the ',' is not within\n     * a sub-expression\n     * e.g.: str = \"x,pow(3,4)\" returns 2 elements: x and pow(3,4).\n     */\n    splitFunctionParams(toSplit: string) {\n        // do not split on ',' within matching brackets.\n        let pCount = 0,\n            paramStr = '';\n        const params = [];\n        for (let chr of toSplit.split('')) {\n            if (chr === ',' && pCount === 0) {\n                // Found function param, save 'em\n                params.push(paramStr);\n                paramStr = '';\n            } else if (chr === '(') {\n                pCount++;\n                paramStr += chr;\n            } else if (chr === ')') {\n                pCount--;\n                paramStr += chr;\n                if (pCount < 0) {\n                    throw new Error('ERROR: Too many closing parentheses!');\n                }\n            } else {\n                paramStr += chr;\n            }\n        }\n        if (pCount !== 0) {\n            throw new Error('ERROR: Too many opening parentheses!');\n        }\n        if (paramStr.length > 0) {\n            params.push(paramStr);\n        }\n        return params;\n    }\n\n    /**\n     * Cleans the input string from unnecessary whitespace,\n     * and replaces some known constants:\n     */\n    cleanupInputFormula(s: string) {\n        const resParts: string[] = [];\n        const srcParts = s.split('\"');\n        srcParts.forEach((part, index) => {\n            // skip parts marked as string\n            if (index % 2 === 0) {\n                part = part.replace(/[\\s]+/g, '');\n                // surround known math constants with [], to parse them as named variables [xxx]:\n                Object.keys(MATH_CONSTANTS).forEach((c) => {\n                    part = part.replace(new RegExp(`\\\\b${c}\\\\b`, 'g'), `[${c}]`);\n                });\n            }\n            resParts.push(part);\n        });\n        return resParts.join('\"');\n    }\n\n    /**\n     * Parses the given formula string by using a state machine into a single Expression object,\n     * which represents an expression tree (aka AST).\n     *\n     * First, we split the string into 'expression': An expression can be:\n     *   - a number, e.g. '3.45'\n     *   - an unknown variable, e.g. 'x'\n     *   - a single char operator, such as '*','+' etc...\n     *   - a named variable, in [], e.g. [myvar]\n     *   - a function, such as sin(x)\n     *   - a parenthessed expression, containing other expressions\n     *\n     * We want to create an expression tree out of the string. This is done in 2 stages:\n     * 1. form single expressions from the string: parse the string into known expression objects:\n     *   - numbers/[variables]/\"strings\"\n     *   - operators\n     *   - braces (with a sub-expression)\n     *   - functions (with sub-expressions (aka argument expressions))\n     *   This will lead to an array of expressions.\n     *  As an example:\n     *  \"2 + 3 * (4 + 3 ^ 5) * sin(PI * x)\" forms an array of the following expressions:\n     *  `[2, +, 3, *, bracketExpr(4,+,3,^,5), * , functionExpr(PI,*,x)]`\n     * 2. From the raw expression array we form an expression tree by evaluating the expressions in the correct order:\n     *    e.g.:\n     *  the expression array `[2, +, 3, *, bracketExpr(4,+,3,^,5), * , functionExpr(PI,*,x)]` will be transformed into the expression tree:\n     *  ```\n     *         root expr:  (+)\n     *                     / \\\n     *                    2    (*)\n     *                        / \\\n     *                     (*)  functionExpr(...)\n     *                     / \\\n     *                    3   (bracket(..))\n     * ```\n     *\n     * In the end, we have a single root expression node, which then can be evaluated in the evaluate() function.\n     *\n     * @param {String} str The formula string, e.g. '3*sin(PI/x)'\n     * @returns {Expression} An expression object, representing the expression tree\n     */\n    parse(str: string) {\n        // clean the input string first. spaces, math constant replacements etc.:\n        str = this.cleanupInputFormula(str);\n        // start recursive call to parse:\n        return this._do_parse(str);\n    }\n\n    /**\n     * @see parse(): this is the recursive parse function, without the clean string part.\n     * @param {String} str\n     * @returns {Expression} An expression object, representing the expression tree\n     */\n    _do_parse(str: string): Expression {\n        let lastChar = str.length - 1,\n            act = 0,\n            state:\n                | 'initial'\n                | 'within-nr'\n                | 'within-parentheses'\n                | 'within-func-parentheses'\n                | 'within-named-var'\n                | 'within-string'\n                | 'within-expr'\n                | 'within-bracket'\n                | 'within-func'\n                | 'within-logical-operator'\n                | 'invalid' = 'initial',\n            expressions = [],\n            char = '',\n            tmp = '',\n            funcName = null,\n            pCount = 0,\n            pStringDelimiter = '';\n\n        while (act <= lastChar) {\n            switch (state) {\n                case 'initial':\n                    // None state, the beginning. Read a char and see what happens.\n                    char = str.charAt(act);\n                    if (char.match(/[0-9.]/)) {\n                        // found the beginning of a number, change state to \"within-number\"\n                        state = 'within-nr';\n                        tmp = '';\n                        act--;\n                    } else if (this.isOperator(char)) {\n                        // Simple operators. Note: '-' must be treaten specially,\n                        // it could be part of a number.\n                        // it MUST be part of a number if the last found expression\n                        // was an operator (or the beginning):\n                        if (char === '-') {\n                            if (expressions.length === 0 || this.isOperatorExpr(expressions[expressions.length - 1])) {\n                                state = 'within-nr';\n                                tmp = '-';\n                                break;\n                            }\n                        }\n\n                        // Found a simple operator, store as expression:\n                        if (act === lastChar || this.isOperatorExpr(expressions[expressions.length - 1])) {\n                            state = 'invalid'; // invalid to end with an operator, or have 2 operators in conjunction\n                            break;\n                        } else {\n                            expressions.push(\n                                Expression.createOperatorExpression(\n                                    char,\n                                    new PlaceholderExpression(),\n                                    new PlaceholderExpression()\n                                )\n                            );\n                            state = 'initial';\n                        }\n                    } else if (['>', '<', '=', '!'].includes(char)) {\n                        // found the beginning of a logical operator, change state to \"within-logical-operator\"\n                        if (act === lastChar) {\n                            state = 'invalid'; // invalid to end with a logical operator\n                            break;\n                        } else {\n                            state = 'within-logical-operator';\n                            tmp = char;\n                        }\n                    } else if (char === '(') {\n                        // left parenthes found, seems to be the beginning of a new sub-expression:\n                        state = 'within-parentheses';\n                        tmp = '';\n                        pCount = 0;\n                    } else if (char === '[') {\n                        // left named var separator char found, seems to be the beginning of a named var:\n                        state = 'within-named-var';\n                        tmp = '';\n                    } else if (char.match(/[\"']/)) {\n                        // left string separator char found\n                        state = 'within-string';\n                        pStringDelimiter = char;\n                        tmp = '';\n                    } else if (char.match(/[a-zA-Z]/)) {\n                        // multiple chars means it may be a function, else its a var which counts as own expression:\n                        if (act < lastChar && str.charAt(act + 1).match(/[a-zA-Z0-9_.]/)) {\n                            tmp = char;\n                            state = 'within-func';\n                        } else {\n                            // Single variable found:\n                            // We need to check some special considerations:\n                            // - If the last char was a number (e.g. 3x), we need to create a multiplication out of it (3*x)\n                            if (\n                                expressions.length > 0 &&\n                                expressions[expressions.length - 1] instanceof ValueExpression\n                            ) {\n                                expressions.push(\n                                    Expression.createOperatorExpression(\n                                        '*',\n                                        new PlaceholderExpression(),\n                                        new PlaceholderExpression()\n                                    )\n                                );\n                            }\n                            expressions.push(new VariableExpression(char, this));\n                            this.registerVariable(char);\n                            state = 'initial';\n                            tmp = '';\n                        }\n                    }\n                    break;\n                case 'within-nr':\n                    char = str.charAt(act);\n                    if (char.match(/[0-9.]/)) {\n                        //Still within number, store and continue\n                        tmp += char;\n                        if (act === lastChar) {\n                            expressions.push(new ValueExpression(tmp));\n                            state = 'initial';\n                        }\n                    } else {\n                        // Number finished on last round, so add as expression:\n                        if (tmp === '-') {\n                            // just a single '-' means: a variable could follow (e.g. like in 3*-x), we convert it to -1: (3*-1x)\n                            tmp = '-1';\n                        }\n                        expressions.push(new ValueExpression(tmp));\n                        tmp = '';\n                        state = 'initial';\n                        act--;\n                    }\n                    break;\n\n                case 'within-func':\n                    char = str.charAt(act);\n                    if (char.match(/[a-zA-Z0-9_.]/)) {\n                        tmp += char;\n                    } else if (char === '(') {\n                        funcName = tmp;\n                        tmp = '';\n                        pCount = 0;\n                        state = 'within-func-parentheses';\n                    } else {\n                        throw new Error('Wrong character for function at position ' + act);\n                    }\n\n                    break;\n\n                case 'within-named-var':\n                    char = str.charAt(act);\n                    if (char === ']') {\n                        // end of named var, create expression:\n                        expressions.push(new VariableExpression(tmp, this));\n                        this.registerVariable(tmp);\n                        tmp = '';\n                        state = 'initial';\n                    } else if (char.match(/[a-zA-Z0-9_.]/)) {\n                        tmp += char;\n                    } else {\n                        throw new Error('Character not allowed within named variable: ' + char);\n                    }\n                    break;\n\n                case 'within-string':\n                    char = str.charAt(act);\n                    if (char === pStringDelimiter) {\n                        // end of string, create expression:\n                        expressions.push(new ValueExpression(tmp, 'string'));\n                        tmp = '';\n                        state = 'initial';\n                        pStringDelimiter = '';\n                    } else {\n                        tmp += char;\n                    }\n                    break;\n\n                case 'within-parentheses':\n                case 'within-func-parentheses':\n                    char = str.charAt(act);\n                    if (pStringDelimiter) {\n                        // If string is opened, then:\n                        if (char === pStringDelimiter) {\n                            // end of string\n                            pStringDelimiter = '';\n                        }\n                        // accumulate string chars\n                        tmp += char;\n                    } else if (char === ')') {\n                        //Check if this is the matching closing parenthesis.If not, just read ahead.\n                        if (pCount <= 0) {\n                            // Yes, we found the closing parenthesis, create new sub-expression:\n                            if (state === 'within-parentheses') {\n                                expressions.push(new BracketExpression(this._do_parse(tmp)));\n                            } else if (state === 'within-func-parentheses') {\n                                // Function found: create expressions from the inner argument\n                                // string, and create a function expression with it:\n                                let args = this.splitFunctionParams(tmp).map((a) => this._do_parse(a));\n                                expressions.push(new FunctionExpression(funcName, args, this));\n                                funcName = null;\n                            }\n                            state = 'initial';\n                        } else {\n                            pCount--;\n                            tmp += char;\n                        }\n                    } else if (char === '(') {\n                        // begin of a new sub-parenthesis, increase counter:\n                        pCount++;\n                        tmp += char;\n                    } else if (char.match(/[\"']/)) {\n                        // start of string\n                        pStringDelimiter = char;\n                        tmp += char;\n                    } else {\n                        // all other things are just added to the sub-expression:\n                        tmp += char;\n                    }\n                    break;\n\n                case 'within-logical-operator':\n                    char = str.charAt(act);\n                    if (char === '=') {\n                        // the second char of a logical operator\n                        // can only be an equal sign\n                        tmp += char;\n                        act++;\n                    }\n                    // logical operator finished, create expression:\n                    expressions.push(\n                        Expression.createOperatorExpression(\n                            tmp,\n                            new PlaceholderExpression(),\n                            new PlaceholderExpression()\n                        )\n                    );\n                    tmp = '';\n                    state = 'initial';\n                    act--;\n                    break;\n            }\n            act++;\n        }\n\n        if (state !== 'initial') {\n            throw new Error('Could not parse formula: Syntax error.');\n        }\n\n        return this.buildExpressionTree(expressions);\n    }\n\n    /**\n     * @see parse(): Builds an expression tree from the given expression array.\n     * Builds a tree with a single root expression in the correct order of operator precedence.\n     *\n     * Note that the given expression objects are modified and linked.\n     *\n     * @param {*} expressions\n     * @return {Expression} The root Expression of the built expression tree\n     */\n    buildExpressionTree(expressions: Expression[]): Expression {\n        if (expressions.length < 1) {\n            throw new Error('No expression given!');\n        }\n        const exprCopy = [...expressions];\n        let idx = 0;\n        let expr = null;\n        // Replace all Power expressions with a partial tree:\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof PowerExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.base = exprCopy[idx - 1];\n                expr.exponent = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        // Replace all Mult/Div expressions with a partial tree:\n        idx = 0;\n        expr = null;\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof MultDivExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.left = exprCopy[idx - 1];\n                expr.right = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        // Replace all Plus/Minus expressions with a partial tree:\n        idx = 0;\n        expr = null;\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof PlusMinusExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.left = exprCopy[idx - 1];\n                expr.right = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        // Replace all Logical expressions with a partial tree:\n        idx = 0;\n        expr = null;\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof LogicalExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.left = exprCopy[idx - 1];\n                expr.right = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        if (exprCopy.length !== 1) {\n            throw new Error('Could not parse formula: incorrect syntax?');\n        }\n        return exprCopy[0];\n    }\n\n    isOperator(char: string | null) {\n        return typeof char === 'string' && char.match(/[+\\-*/^]/);\n    }\n\n    isOperatorExpr(expr: Expression) {\n        return (\n            expr instanceof PlusMinusExpression ||\n            expr instanceof MultDivExpression ||\n            expr instanceof PowerExpression ||\n            expr instanceof LogicalExpression\n        );\n    }\n\n    registerVariable(varName: string) {\n        if (this._variables.indexOf(varName) < 0) {\n            this._variables.push(varName);\n        }\n    }\n\n    getVariables() {\n        return this._variables;\n    }\n\n    /**\n     * Evaluates a Formula by delivering values for the Formula's variables.\n     * E.g. if the formula is '3*x^2 + 2*x + 4', you should call `evaulate` as follows:\n     *\n     * evaluate({x:2}) --> Result: 20\n     *\n     * @param {ValueObject|Array<ValueObject>} valueObj An object containing values for variables and (unknown) functions,\n     *   or an array of such objects: If an array is given, all objects are evaluated and the results\n     *   also returned as array.\n     * @return {Number|String|(Number|String)[]} The evaluated result, or an array with results\n     */\n    evaluate(valueObj: ValueObject | ValueObject[]): number | string | (number | string)[] {\n        // resolve multiple value objects recursively:\n        if (valueObj instanceof Array) {\n            return valueObj.map((v) => this.evaluate(v)) as (number | string)[];\n        }\n        let expr = this.getExpression();\n        if (!(expr instanceof Expression)) {\n            throw new Error('No expression set: Did you init the object with a Formula?');\n        }\n        if (this.options.memoization) {\n            let res = this.resultFromMemory(valueObj);\n            if (res !== null) {\n                return res;\n            } else {\n                res = expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n                this.storeInMemory(valueObj, res);\n                return res;\n            }\n        }\n        return expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n    }\n\n    hashValues(valueObj: ValueObject) {\n        return JSON.stringify(valueObj);\n    }\n\n    resultFromMemory(valueObj: ValueObject): number | string | null {\n        let key = this.hashValues(valueObj);\n        let res = this._memory[key];\n        if (res !== undefined) {\n            return res;\n        } else {\n            return null;\n        }\n    }\n\n    storeInMemory(valueObj: ValueObject, value: number | string) {\n        this._memory[this.hashValues(valueObj)] = value;\n    }\n\n    getExpression() {\n        return this.formulaExpression;\n    }\n\n    getExpressionString() {\n        return this.formulaExpression ? this.formulaExpression.toString() : '';\n    }\n\n    static calc(formula: string, valueObj: ValueObject | null = null, options = {}) {\n        valueObj = valueObj ?? {};\n        return new Formula(formula, options).evaluate(valueObj);\n    }\n\n    /**\n     * Implements an if/else condition as a function: Checks the predicate\n     * if it evaluates to true-ish (> 0, true, non-empty string, etc.). Returns the trueValue if\n     * the predicate evaluates to true, else the falseValue.\n     * allowed formula functio\n     * @param predicate\n     * @param trueValue\n     * @param falseValue\n     * @returns\n     */\n    ifElse(predicate: any, trueValue: any, falseValue: any): any {\n        if (predicate) {\n            return trueValue;\n        } else {\n            return falseValue;\n        }\n    }\n\n    first(...args: any[]): any {\n        for (const arg of args) {\n            if (arg instanceof Array) {\n                let res = this.first(...arg);\n                if (res) {\n                    return res;\n                }\n            } else {\n                if (arg) {\n                    return arg;\n                }\n            }\n        }\n        if (args.length > 0) {\n            const last = args[args.length - 1];\n            if (last instanceof Array) {\n                return this.first(...last);\n            } else {\n                return last;\n            }\n        }\n        throw new Error('first(): At least one argument is required');\n    }\n}\n"],"names":["TokenType"],"mappings":"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"}