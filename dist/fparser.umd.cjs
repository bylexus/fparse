(function(c,l){typeof exports=="object"&&typeof module!="undefined"?module.exports=l():typeof define=="function"&&define.amd?define(l):(c=typeof globalThis!="undefined"?globalThis:c||self,c.Formula=l())})(this,function(){"use strict";var O=Object.defineProperty;var T=(c,l,w)=>l in c?O(c,l,{enumerable:!0,configurable:!0,writable:!0,value:w}):c[l]=w;var n=(c,l,w)=>T(c,typeof l!="symbol"?l+"":l,w);const c={PI:Math.PI,E:Math.E,LN2:Math.LN2,LN10:Math.LN10,LOG2E:Math.LOG2E,LOG10E:Math.LOG10E,SQRT1_2:Math.SQRT1_2,SQRT2:Math.SQRT2};class l{static throwIfNotNumber(i){if(typeof i==="string")throw new Error("Strings are not allowed in math operations")}}class w{static throwIfNotNumber(i){if(typeof i==="string")throw new Error("Strings are not allowed in math operations")}}class h{static createOperatorExpression(i,e,t){if(i==="^")return new d(e,t);if(["*","/"].includes(i))return new b(i,e,t);if(["+","-"].includes(i))return new x(i,e,t);if(["<",">","<=",">=","=","!="].includes(i))return new v(i,e,t);throw new Error(`Unknown operator: ${i}`)}evaluate(i={}){throw new Error("Empty Expression - Must be defined in child classes")}toString(){return""}}class k extends h{constructor(e){super();n(this,"innerExpression");if(this.innerExpression=e,!(this.innerExpression instanceof h))throw new Error("No inner expression given for bracket expression")}evaluate(e={}){return this.innerExpression.evaluate(e)}toString(){return`(${this.innerExpression.toString()})`}}class m extends h{constructor(e,t="number"){super();n(this,"value");n(this,"type");switch(this.value=Number(e),t){case"number":if(this.value=Number(e),isNaN(this.value))throw new Error("Cannot parse number: "+e);break;case"string":this.value=String(e);break;default:throw new Error("Invalid value type: "+t)}this.type=t}evaluate(){return this.value}toString(){switch(this.type){case"number":return String(this.value);case"string":return'"'+this.value+'"';default:throw new Error("Invalid type")}}}class x extends h{constructor(e,t,r){super();n(this,"operator");n(this,"left");n(this,"right");if(!["+","-"].includes(e))throw new Error(`Operator not allowed in Plus/Minus expression: ${e}`);this.operator=e,this.left=t,this.right=r}evaluate(e={}){const t=this.left.evaluate(e),r=this.right.evaluate(e);if(l.throwIfNotNumber(t),l.throwIfNotNumber(r),this.operator==="+")return Number(t)+Number(r);if(this.operator==="-")return Number(t)-Number(r);throw new Error("Unknown operator for PlusMinus expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}class b extends h{constructor(e,t,r){super();n(this,"operator");n(this,"left");n(this,"right");if(!["*","/"].includes(e))throw new Error(`Operator not allowed in Multiply/Division expression: ${e}`);this.operator=e,this.left=t,this.right=r}evaluate(e={}){const t=this.left.evaluate(e),r=this.right.evaluate(e);if(l.throwIfNotNumber(t),l.throwIfNotNumber(r),this.operator==="*")return Number(t)*Number(r);if(this.operator==="/")return Number(t)/Number(r);throw new Error("Unknown operator for MultDiv expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}class d extends h{constructor(e,t){super();n(this,"base");n(this,"exponent");this.base=e,this.exponent=t}evaluate(e={}){const t=this.base.evaluate(e),r=this.exponent.evaluate(e);return l.throwIfNotNumber(t),l.throwIfNotNumber(r),Math.pow(Number(t),Number(r))}toString(){return`${this.base.toString()}^${this.exponent.toString()}`}}class v extends h{constructor(e,t,r){super();n(this,"operator");n(this,"left");n(this,"right");if(!["<",">","<=",">=","=","!="].includes(e))throw new Error(`Operator not allowed in Logical expression: ${e}`);this.operator=e,this.left=t,this.right=r}evaluate(e={}){const t=this.left.evaluate(e),r=this.right.evaluate(e);switch(this.operator){case"<":return t<r?1:0;case">":return t>r?1:0;case"<=":return t<=r?1:0;case">=":return t>=r?1:0;case"=":return t===r?1:0;case"!=":return t!==r?1:0}throw new Error("Unknown operator for Logical expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}class M extends h{constructor(e,t,r=null){super();n(this,"fn");n(this,"varPath");n(this,"argumentExpressions");n(this,"formulaObject");n(this,"blacklisted");this.fn=e!=null?e:"",this.varPath=this.fn.split("."),this.argumentExpressions=t||[],this.formulaObject=r,this.blacklisted=void 0}evaluate(e={}){var a;e=e||{};const t=this.argumentExpressions.map(s=>s.evaluate(e));try{let s=g(e,this.varPath,this.fn);if(s instanceof Function)return s.apply(this,t)}catch(s){}let r;try{r=g((a=this.formulaObject)!=null?a:{},this.varPath,this.fn)}catch(s){}if(this.formulaObject&&r instanceof Function){if(this.isBlacklisted())throw new Error("Blacklisted function called: "+this.fn);return r.apply(this.formulaObject,t)}try{const s=g(Math,this.varPath,this.fn);if(s instanceof Function)return t.forEach(o=>{w.throwIfNotNumber(o)}),s.apply(this,t)}catch(s){}throw new Error("Function not found: "+this.fn)}toString(){return`${this.fn}(${this.argumentExpressions.map(e=>e.toString()).join(", ")})`}isBlacklisted(){return this.blacklisted===void 0&&(this.blacklisted=y.functionBlacklist.includes(this.formulaObject?this.formulaObject[this.fn]:null)),this.blacklisted}}function g(p,i,e){let t=p;for(let r of i){if(typeof t!="object")throw new Error(`Cannot evaluate ${r}, property not found (from path ${e})`);if(t[r]===void 0)throw new Error(`Cannot evaluate ${r}, property not found (from path ${e})`);t=t[r]}if(typeof t=="object")throw new Error("Invalid value");return t}class N extends h{constructor(e,t=null){super();n(this,"fullPath");n(this,"varPath");n(this,"formulaObject");this.formulaObject=t,this.fullPath=e,this.varPath=e.split(".")}evaluate(e={}){var r;let t;try{t=g(e,this.varPath,this.fullPath)}catch(a){}if(t===void 0&&(t=g((r=this.formulaObject)!=null?r:{},this.varPath,this.fullPath)),typeof t=="function"||typeof t=="object")throw new Error(`Cannot use ${this.fullPath} as value: It contains a non-numerical value.`);return t}toString(){return`${this.varPath.join(".")}`}}const u=class u{constructor(i,e={}){n(this,"formulaExpression");n(this,"options");n(this,"formulaStr");n(this,"_variables");n(this,"_memory");this.formulaExpression=null,this.options={memoization:!1,...e},this.formulaStr="",this._variables=[],this._memory={},this.setFormula(i)}setFormula(i){return i&&(this.formulaExpression=null,this._variables=[],this._memory={},this.formulaStr=i,this.formulaExpression=this.parse(i)),this}enableMemoization(){this.options.memoization=!0}disableMemoization(){this.options.memoization=!1,this._memory={}}splitFunctionParams(i){let e=0,t="";const r=[];for(let a of i.split(""))if(a===","&&e===0)r.push(t),t="";else if(a==="(")e++,t+=a;else if(a===")"){if(e--,t+=a,e<0)throw new Error("ERROR: Too many closing parentheses!")}else t+=a;if(e!==0)throw new Error("ERROR: Too many opening parentheses!");return t.length>0&&r.push(t),r}cleanupInputFormula(i){const e=[];return i.split('"').forEach((r,a)=>{a%2===0&&(r=r.replace(/[\s]+/g,""),Object.keys(c).forEach(s=>{r=r.replace(new RegExp(`\\b${s}\\b`,"g"),`[${s}]`)})),e.push(r)}),e.join('"')}parse(i){return i=this.cleanupInputFormula(i),this._do_parse(i)}_do_parse(i){let e=i.length-1,t=0,r="initial",a=[],s="",o="",S=null,E=0,f="";for(;t<=e;){switch(r){case"initial":if(s=i.charAt(t),s.match(/[0-9.]/))r="within-nr",o="",t--;else if(this.isOperator(s)){if(s==="-"&&(a.length===0||this.isOperatorExpr(a[a.length-1]))){r="within-nr",o="-";break}if(t===e||this.isOperatorExpr(a[a.length-1])){r="invalid";break}else a.push(h.createOperatorExpression(s,new h,new h)),r="initial"}else if([">","<","=","!"].includes(s))if(t===e){r="invalid";break}else r="within-logical-operator",o=s;else s==="("?(r="within-parentheses",o="",E=0):s==="["?(r="within-named-var",o=""):s.match(/["']/)?(r="within-string",f=s,o=""):s.match(/[a-zA-Z]/)&&(t<e&&i.charAt(t+1).match(/[a-zA-Z0-9_.]/)?(o=s,r="within-func"):(a.length>0&&a[a.length-1]instanceof m&&a.push(h.createOperatorExpression("*",new h,new h)),a.push(new N(s,this)),this.registerVariable(s),r="initial",o=""));break;case"within-nr":s=i.charAt(t),s.match(/[0-9.]/)?(o+=s,t===e&&(a.push(new m(o)),r="initial")):(o==="-"&&(o="-1"),a.push(new m(o)),o="",r="initial",t--);break;case"within-func":if(s=i.charAt(t),s.match(/[a-zA-Z0-9_.]/))o+=s;else if(s==="(")S=o,o="",E=0,r="within-func-parentheses";else throw new Error("Wrong character for function at position "+t);break;case"within-named-var":if(s=i.charAt(t),s==="]")a.push(new N(o,this)),this.registerVariable(o),o="",r="initial";else if(s.match(/[a-zA-Z0-9_.]/))o+=s;else throw new Error("Character not allowed within named variable: "+s);break;case"within-string":s=i.charAt(t),s===f?(a.push(new m(o,"string")),o="",r="initial",f=""):o+=s;break;case"within-parentheses":case"within-func-parentheses":if(s=i.charAt(t),f)s===f&&(f=""),o+=s;else if(s===")")if(E<=0){if(r==="within-parentheses")a.push(new k(this._do_parse(o)));else if(r==="within-func-parentheses"){let P=this.splitFunctionParams(o).map($=>this._do_parse($));a.push(new M(S,P,this)),S=null}r="initial"}else E--,o+=s;else s==="("?(E++,o+=s):(s.match(/["']/)&&(f=s),o+=s);break;case"within-logical-operator":s=i.charAt(t),s==="="&&(o+=s,t++),a.push(h.createOperatorExpression(o,new h,new h)),o="",r="initial",t--;break}t++}if(r!=="initial")throw new Error("Could not parse formula: Syntax error.");return this.buildExpressionTree(a)}buildExpressionTree(i){if(i.length<1)throw new Error("No expression given!");const e=[...i];let t=0,r=null;for(;t<e.length;)if(r=e[t],r instanceof d){if(t===0||t===e.length-1)throw new Error("Wrong operator position!");r.base=e[t-1],r.exponent=e[t+1],e[t-1]=r,e.splice(t,2)}else t++;for(t=0,r=null;t<e.length;)if(r=e[t],r instanceof b){if(t===0||t===e.length-1)throw new Error("Wrong operator position!");r.left=e[t-1],r.right=e[t+1],e[t-1]=r,e.splice(t,2)}else t++;for(t=0,r=null;t<e.length;)if(r=e[t],r instanceof x){if(t===0||t===e.length-1)throw new Error("Wrong operator position!");r.left=e[t-1],r.right=e[t+1],e[t-1]=r,e.splice(t,2)}else t++;for(t=0,r=null;t<e.length;)if(r=e[t],r instanceof v){if(t===0||t===e.length-1)throw new Error("Wrong operator position!");r.left=e[t-1],r.right=e[t+1],e[t-1]=r,e.splice(t,2)}else t++;if(e.length!==1)throw new Error("Could not parse formula: incorrect syntax?");return e[0]}isOperator(i){return typeof i=="string"&&i.match(/[+\-*/^]/)}isOperatorExpr(i){return i instanceof x||i instanceof b||i instanceof d||i instanceof v}registerVariable(i){this._variables.indexOf(i)<0&&this._variables.push(i)}getVariables(){return this._variables}evaluate(i){if(i instanceof Array)return i.map(t=>this.evaluate(t));let e=this.getExpression();if(!(e instanceof h))throw new Error("No expression set: Did you init the object with a Formula?");if(this.options.memoization){let t=this.resultFromMemory(i);return t!==null||(t=e.evaluate({...c,...i}),this.storeInMemory(i,t)),t}return e.evaluate({...c,...i})}hashValues(i){return JSON.stringify(i)}resultFromMemory(i){let e=this.hashValues(i),t=this._memory[e];return t!==void 0?t:null}storeInMemory(i,e){this._memory[this.hashValues(i)]=e}getExpression(){return this.formulaExpression}getExpressionString(){return this.formulaExpression?this.formulaExpression.toString():""}static calc(i,e=null,t={}){return e=e!=null?e:{},new u(i,t).evaluate(e)}};n(u,"Expression",h),n(u,"BracketExpression",k),n(u,"PowerExpression",d),n(u,"MultDivExpression",b),n(u,"PlusMinusExpression",x),n(u,"LogicalExpression",v),n(u,"ValueExpression",m),n(u,"VariableExpression",N),n(u,"FunctionExpression",M),n(u,"MATH_CONSTANTS",c),n(u,"functionBlacklist",Object.getOwnPropertyNames(u.prototype).filter(i=>u.prototype[i]instanceof Function).map(i=>u.prototype[i]));let y=u;return y});
//# sourceMappingURL=fparser.umd.cjs.map
