(function(c,l){typeof exports=="object"&&typeof module!="undefined"?module.exports=l():typeof define=="function"&&define.amd?define(l):(c=typeof globalThis!="undefined"?globalThis:c||self,c.Formula=l())})(this,function(){"use strict";var M=Object.defineProperty;var A=(c,l,w)=>l in c?M(c,l,{enumerable:!0,configurable:!0,writable:!0,value:w}):c[l]=w;var n=(c,l,w)=>(A(c,typeof l!="symbol"?l+"":l,w),w);const c={PI:Math.PI,E:Math.E,LN2:Math.LN2,LN10:Math.LN10,LOG2E:Math.LOG2E,LOG10E:Math.LOG10E,SQRT1_2:Math.SQRT1_2,SQRT2:Math.SQRT2};class l{static throwIfNotNumber(i){if(typeof i==="string")throw new Error("Strings are not allowed in math operations")}}class w{static throwIfNotNumber(i){if(typeof i==="string")throw new Error("Strings are not allowed in math operations")}}class u{static createOperatorExpression(i,e,t){if(i==="^")return new y(e,t);if(["*","/"].includes(i))return new d(i,e,t);if(["+","-"].includes(i))return new E(i,e,t);if(["<",">","<=",">=","=","!="].includes(i))return new p(i,e,t);throw new Error(`Unknown operator: ${i}`)}toString(){return""}}class g extends u{evaluate(i){throw new Error("PlaceholderExpression cannot be evaluated")}toString(){return"[placeholder]"}}class O extends u{constructor(e){super();n(this,"innerExpression");if(this.innerExpression=e,!(this.innerExpression instanceof u))throw new Error("No inner expression given for bracket expression")}evaluate(e={}){return this.innerExpression.evaluate(e)}toString(){return`(${this.innerExpression.toString()})`}}class b extends u{constructor(e,t="number"){super();n(this,"value");n(this,"type");switch(this.value=Number(e),t){case"number":if(this.value=Number(e),isNaN(this.value))throw new Error("Cannot parse number: "+e);break;case"string":this.value=String(e);break;default:throw new Error("Invalid value type: "+t)}this.type=t}evaluate(){return this.value}toString(){switch(this.type){case"number":return String(this.value);case"string":return'"'+this.value+'"';default:throw new Error("Invalid type")}}}class E extends u{constructor(e,t,r){super();n(this,"operator");n(this,"left");n(this,"right");if(!["+","-"].includes(e))throw new Error(`Operator not allowed in Plus/Minus expression: ${e}`);this.operator=e,this.left=t,this.right=r}evaluate(e={}){const t=this.left.evaluate(e),r=this.right.evaluate(e);if(l.throwIfNotNumber(t),l.throwIfNotNumber(r),this.operator==="+")return Number(t)+Number(r);if(this.operator==="-")return Number(t)-Number(r);throw new Error("Unknown operator for PlusMinus expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}n(E,"PLUS","+"),n(E,"MINUS","-");class d extends u{constructor(e,t,r){super();n(this,"operator");n(this,"left");n(this,"right");if(!["*","/"].includes(e))throw new Error(`Operator not allowed in Multiply/Division expression: ${e}`);this.operator=e,this.left=t,this.right=r}evaluate(e={}){const t=this.left.evaluate(e),r=this.right.evaluate(e);if(l.throwIfNotNumber(t),l.throwIfNotNumber(r),this.operator==="*")return Number(t)*Number(r);if(this.operator==="/")return Number(t)/Number(r);throw new Error("Unknown operator for MultDiv expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}n(d,"MULT","*"),n(d,"DIV","/");class y extends u{constructor(e,t){super();n(this,"base");n(this,"exponent");this.base=e,this.exponent=t}evaluate(e={}){const t=this.base.evaluate(e),r=this.exponent.evaluate(e);return l.throwIfNotNumber(t),l.throwIfNotNumber(r),Math.pow(Number(t),Number(r))}toString(){return`${this.base.toString()}^${this.exponent.toString()}`}}class p extends u{constructor(e,t,r){super();n(this,"operator");n(this,"left");n(this,"right");if(!["<",">","<=",">=","=","!="].includes(e))throw new Error(`Operator not allowed in Logical expression: ${e}`);this.operator=e,this.left=t,this.right=r}evaluate(e={}){const t=this.left.evaluate(e),r=this.right.evaluate(e);switch(this.operator){case"<":return t<r?1:0;case">":return t>r?1:0;case"<=":return t<=r?1:0;case">=":return t>=r?1:0;case"=":return t===r?1:0;case"!=":return t!==r?1:0}throw new Error("Unknown operator for Logical expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}n(p,"LT","<"),n(p,"GT",">"),n(p,"LTE","<="),n(p,"GTE",">="),n(p,"EQ","="),n(p,"NEQ","!=");class P extends u{constructor(e,t,r=null){super();n(this,"fn");n(this,"varPath");n(this,"argumentExpressions");n(this,"formulaObject");n(this,"blacklisted");this.fn=e!=null?e:"",this.varPath=this.fn.split("."),this.argumentExpressions=t||[],this.formulaObject=r,this.blacklisted=void 0}evaluate(e={}){var o;e=e||{};const t=this.argumentExpressions.map(s=>s.evaluate(e));try{let s=x(e,this.varPath,this.fn);if(s instanceof Function)return s.apply(this,t)}catch(s){}let r;try{r=x((o=this.formulaObject)!=null?o:{},this.varPath,this.fn)}catch(s){}if(this.formulaObject&&r instanceof Function){if(this.isBlacklisted())throw new Error("Blacklisted function called: "+this.fn);return r.apply(this.formulaObject,t)}try{const s=x(Math,this.varPath,this.fn);if(s instanceof Function)return t.forEach(a=>{w.throwIfNotNumber(a)}),s.apply(this,t)}catch(s){}throw new Error("Function not found: "+this.fn)}toString(){return`${this.fn}(${this.argumentExpressions.map(e=>e.toString()).join(", ")})`}isBlacklisted(){return this.blacklisted===void 0&&(this.blacklisted=N.functionBlacklist.includes(this.formulaObject?this.formulaObject[this.fn]:null)),this.blacklisted}}function x(f,i,e){let t=f,r=null;for(let o of i){if(!["object","string"].includes(typeof t))throw new Error(`Cannot evaluate ${o}, property not found (from path ${e})`);if(typeof t=="object"&&!(o in t))throw new Error(`Cannot evaluate ${o}, property not found (from path ${e})`);if(typeof t=="string"&&!t.hasOwnProperty(o))throw new Error(`Cannot evaluate ${o}, property not found (from path ${e})`);r=t,t=t[o]}if(typeof t=="object"&&!(t instanceof Array))throw new Error("Invalid value");return typeof t=="function"&&r&&(t=t.bind(r)),t}class S extends u{constructor(e,t=null){super();n(this,"fullPath");n(this,"varPath");n(this,"formulaObject");this.formulaObject=t,this.fullPath=e,this.varPath=e.split(".")}evaluate(e={}){var r;let t;try{t=x(e,this.varPath,this.fullPath)}catch(o){}if(t===void 0&&(t=x((r=this.formulaObject)!=null?r:{},this.varPath,this.fullPath)),typeof t=="function"||typeof t=="object")throw new Error(`Cannot use ${this.fullPath} as value: It contains a non-numerical value.`);return t}toString(){return`${this.varPath.join(".")}`}}const h=class h{constructor(i,e={}){n(this,"formulaExpression");n(this,"options");n(this,"formulaStr");n(this,"_variables");n(this,"_memory");this.formulaExpression=null,this.options={memoization:!1,...e},this.formulaStr="",this._variables=[],this._memory={},this.setFormula(i)}setFormula(i){return i&&(this.formulaExpression=null,this._variables=[],this._memory={},this.formulaStr=i,this.formulaExpression=this.parse(i)),this}enableMemoization(){this.options.memoization=!0}disableMemoization(){this.options.memoization=!1,this._memory={}}splitFunctionParams(i){let e=0,t="";const r=[];for(let o of i.split(""))if(o===","&&e===0)r.push(t),t="";else if(o==="(")e++,t+=o;else if(o===")"){if(e--,t+=o,e<0)throw new Error("ERROR: Too many closing parentheses!")}else t+=o;if(e!==0)throw new Error("ERROR: Too many opening parentheses!");return t.length>0&&r.push(t),r}cleanupInputFormula(i){const e=[];return i.split('"').forEach((r,o)=>{o%2===0&&(r=r.replace(/[\s]+/g,""),Object.keys(c).forEach(s=>{r=r.replace(new RegExp(`\\b${s}\\b`,"g"),`[${s}]`)})),e.push(r)}),e.join('"')}parse(i){return i=this.cleanupInputFormula(i),this._do_parse(i)}_do_parse(i){let e=i.length-1,t=0,r="initial",o=[],s="",a="",k=null,v=0,m="";for(;t<=e;){switch(r){case"initial":if(s=i.charAt(t),s.match(/[0-9.]/))r="within-nr",a="",t--;else if(this.isOperator(s)){if(s==="-"&&(o.length===0||this.isOperatorExpr(o[o.length-1]))){r="within-nr",a="-";break}if(t===e||this.isOperatorExpr(o[o.length-1])){r="invalid";break}else o.push(u.createOperatorExpression(s,new g,new g)),r="initial"}else if([">","<","=","!"].includes(s))if(t===e){r="invalid";break}else r="within-logical-operator",a=s;else s==="("?(r="within-parentheses",a="",v=0):s==="["?(r="within-named-var",a=""):s.match(/["']/)?(r="within-string",m=s,a=""):s.match(/[a-zA-Z]/)&&(t<e&&i.charAt(t+1).match(/[a-zA-Z0-9_.]/)?(a=s,r="within-func"):(o.length>0&&o[o.length-1]instanceof b&&o.push(u.createOperatorExpression("*",new g,new g)),o.push(new S(s,this)),this.registerVariable(s),r="initial",a=""));break;case"within-nr":s=i.charAt(t),s.match(/[0-9.]/)?(a+=s,t===e&&(o.push(new b(a)),r="initial")):(a==="-"&&(a="-1"),o.push(new b(a)),a="",r="initial",t--);break;case"within-func":if(s=i.charAt(t),s.match(/[a-zA-Z0-9_.]/))a+=s;else if(s==="(")k=a,a="",v=0,r="within-func-parentheses";else throw new Error("Wrong character for function at position "+t);break;case"within-named-var":if(s=i.charAt(t),s==="]")o.push(new S(a,this)),this.registerVariable(a),a="",r="initial";else if(s.match(/[a-zA-Z0-9_.]/))a+=s;else throw new Error("Character not allowed within named variable: "+s);break;case"within-string":s=i.charAt(t),s===m?(o.push(new b(a,"string")),a="",r="initial",m=""):a+=s;break;case"within-parentheses":case"within-func-parentheses":if(s=i.charAt(t),m)s===m&&(m=""),a+=s;else if(s===")")if(v<=0){if(r==="within-parentheses")o.push(new O(this._do_parse(a)));else if(r==="within-func-parentheses"){let $=this.splitFunctionParams(a).map(T=>this._do_parse(T));o.push(new P(k,$,this)),k=null}r="initial"}else v--,a+=s;else s==="("?(v++,a+=s):(s.match(/["']/)&&(m=s),a+=s);break;case"within-logical-operator":s=i.charAt(t),s==="="&&(a+=s,t++),o.push(u.createOperatorExpression(a,new g,new g)),a="",r="initial",t--;break}t++}if(r!=="initial")throw new Error("Could not parse formula: Syntax error.");return this.buildExpressionTree(o)}buildExpressionTree(i){if(i.length<1)throw new Error("No expression given!");const e=[...i];let t=0,r=null;for(;t<e.length;)if(r=e[t],r instanceof y){if(t===0||t===e.length-1)throw new Error("Wrong operator position!");r.base=e[t-1],r.exponent=e[t+1],e[t-1]=r,e.splice(t,2)}else t++;for(t=0,r=null;t<e.length;)if(r=e[t],r instanceof d){if(t===0||t===e.length-1)throw new Error("Wrong operator position!");r.left=e[t-1],r.right=e[t+1],e[t-1]=r,e.splice(t,2)}else t++;for(t=0,r=null;t<e.length;)if(r=e[t],r instanceof E){if(t===0||t===e.length-1)throw new Error("Wrong operator position!");r.left=e[t-1],r.right=e[t+1],e[t-1]=r,e.splice(t,2)}else t++;for(t=0,r=null;t<e.length;)if(r=e[t],r instanceof p){if(t===0||t===e.length-1)throw new Error("Wrong operator position!");r.left=e[t-1],r.right=e[t+1],e[t-1]=r,e.splice(t,2)}else t++;if(e.length!==1)throw new Error("Could not parse formula: incorrect syntax?");return e[0]}isOperator(i){return typeof i=="string"&&i.match(/[+\-*/^]/)}isOperatorExpr(i){return i instanceof E||i instanceof d||i instanceof y||i instanceof p}registerVariable(i){this._variables.indexOf(i)<0&&this._variables.push(i)}getVariables(){return this._variables}evaluate(i){if(i instanceof Array)return i.map(t=>this.evaluate(t));let e=this.getExpression();if(!(e instanceof u))throw new Error("No expression set: Did you init the object with a Formula?");if(this.options.memoization){let t=this.resultFromMemory(i);return t!==null||(t=e.evaluate({...c,...i}),this.storeInMemory(i,t)),t}return e.evaluate({...c,...i})}hashValues(i){return JSON.stringify(i)}resultFromMemory(i){let e=this.hashValues(i),t=this._memory[e];return t!==void 0?t:null}storeInMemory(i,e){this._memory[this.hashValues(i)]=e}getExpression(){return this.formulaExpression}getExpressionString(){return this.formulaExpression?this.formulaExpression.toString():""}static calc(i,e=null,t={}){return e=e!=null?e:{},new h(i,t).evaluate(e)}ifElse(i,e,t){return i?e:t}first(...i){for(const e of i)if(e instanceof Array){let t=this.first(...e);if(t)return t}else if(e)return e;if(i.length>0){const e=i[i.length-1];return e instanceof Array?this.first(...e):e}throw new Error("first(): At least one argument is required")}};n(h,"Expression",u),n(h,"BracketExpression",O),n(h,"PowerExpression",y),n(h,"MultDivExpression",d),n(h,"PlusMinusExpression",E),n(h,"LogicalExpression",p),n(h,"ValueExpression",b),n(h,"VariableExpression",S),n(h,"FunctionExpression",P),n(h,"MATH_CONSTANTS",c),n(h,"ALLOWED_FUNCTIONS",["ifElse","first"]),n(h,"functionBlacklist",Object.getOwnPropertyNames(h.prototype).filter(i=>h.prototype[i]instanceof Function&&!h.ALLOWED_FUNCTIONS.includes(i)).map(i=>h.prototype[i]));let N=h;return N});
//# sourceMappingURL=fparser.umd.cjs.map
