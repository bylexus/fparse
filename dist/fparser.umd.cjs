(function(u,p){typeof exports=="object"&&typeof module!="undefined"?module.exports=p():typeof define=="function"&&define.amd?define(p):(u=typeof globalThis!="undefined"?globalThis:u||self,u.Formula=p())})(this,function(){"use strict";var M=Object.defineProperty;var $=(u,p,E)=>p in u?M(u,p,{enumerable:!0,configurable:!0,writable:!0,value:E}):u[p]=E;var r=(u,p,E)=>($(u,typeof p!="symbol"?p+"":p,E),E);function u(o,i,t){let e=o,s=null;for(let n of i){if(!["object","string"].includes(typeof e))throw new Error(`Cannot evaluate ${n}, property not found (from path ${t})`);if(typeof e=="object"&&!(n in e))throw new Error(`Cannot evaluate ${n}, property not found (from path ${t})`);if(typeof e=="string"&&!e.hasOwnProperty(n))throw new Error(`Cannot evaluate ${n}, property not found (from path ${t})`);s=e,e=e[n]}return typeof e=="function"&&s&&(e=e.bind(s)),e}class p{static throwIfNotNumber(i){if(typeof i==="string")throw new Error("Strings are not allowed in math operations")}}class E{static throwIfNotNumber(i){if(typeof i==="string")throw new Error("Strings are not allowed in math operations")}}class m{static createOperatorExpression(i,t,e){const s=typeof i=="string"?i:String(i.value);if(s==="^")return new T(t,e);if(["*","/"].includes(s))return new w(s,t,e);if(["+","-"].includes(s))return new d(s,t,e);if(["<",">","<=",">=","=","!="].includes(s))return new g(s,t,e);throw new Error(`Unknown operator: ${s}`)}toString(){return""}}class P extends m{constructor(t){super();r(this,"innerExpression");if(this.innerExpression=t,!(this.innerExpression instanceof m))throw new Error("No inner expression given for bracket expression")}evaluate(t={}){return this.innerExpression.evaluate(t)}toString(){return`(${this.innerExpression.toString()})`}}class N extends m{constructor(t,e="number"){super();r(this,"value");r(this,"type");switch(this.value=Number(t),e){case"number":if(this.value=Number(t),isNaN(this.value))throw new Error("Cannot parse number: "+t);break;case"string":this.value=String(t);break;default:throw new Error("Invalid value type: "+e)}this.type=e}evaluate(){return this.value}toString(){switch(this.type){case"number":return String(this.value);case"string":return'"'+this.value+'"';default:throw new Error("Invalid type")}}}class d extends m{constructor(t,e,s){super();r(this,"operator");r(this,"left");r(this,"right");if(!["+","-"].includes(t))throw new Error(`Operator not allowed in Plus/Minus expression: ${t}`);this.operator=t,this.left=e,this.right=s}evaluate(t={}){const e=this.left.evaluate(t),s=this.right.evaluate(t);if(E.throwIfNotNumber(e),E.throwIfNotNumber(s),this.operator==="+")return Number(e)+Number(s);if(this.operator==="-")return Number(e)-Number(s);throw new Error("Unknown operator for PlusMinus expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}r(d,"PLUS","+"),r(d,"MINUS","-");class w extends m{constructor(t,e,s){super();r(this,"operator");r(this,"left");r(this,"right");if(!["*","/"].includes(t))throw new Error(`Operator not allowed in Multiply/Division expression: ${t}`);this.operator=t,this.left=e,this.right=s}evaluate(t={}){const e=this.left.evaluate(t),s=this.right.evaluate(t);if(E.throwIfNotNumber(e),E.throwIfNotNumber(s),this.operator==="*")return Number(e)*Number(s);if(this.operator==="/")return Number(e)/Number(s);throw new Error("Unknown operator for MultDiv expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}r(w,"MULT","*"),r(w,"DIV","/");class T extends m{constructor(t,e){super();r(this,"base");r(this,"exponent");this.base=t,this.exponent=e}evaluate(t={}){const e=this.base.evaluate(t),s=this.exponent.evaluate(t);return E.throwIfNotNumber(e),E.throwIfNotNumber(s),Math.pow(Number(e),Number(s))}toString(){return`${this.base.toString()}^${this.exponent.toString()}`}}class g extends m{constructor(t,e,s){super();r(this,"operator");r(this,"left");r(this,"right");if(!["<",">","<=",">=","=","!="].includes(t))throw new Error(`Operator not allowed in Logical expression: ${t}`);this.operator=t,this.left=e,this.right=s}evaluate(t={}){const e=this.left.evaluate(t),s=this.right.evaluate(t);switch(this.operator){case"<":return e<s?1:0;case">":return e>s?1:0;case"<=":return e<=s?1:0;case">=":return e>=s?1:0;case"=":return e===s?1:0;case"!=":return e!==s?1:0}throw new Error("Unknown operator for Logical expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}r(g,"LT","<"),r(g,"GT",">"),r(g,"LTE","<="),r(g,"GTE",">="),r(g,"EQ","="),r(g,"NEQ","!=");class x extends m{constructor(t,e,s=null){super();r(this,"fn");r(this,"varPath");r(this,"argumentExpressions");r(this,"formulaObject");r(this,"blacklisted");this.fn=t!=null?t:"",this.varPath=this.fn.split("."),this.argumentExpressions=e||[],this.formulaObject=s,this.blacklisted=void 0}evaluate(t={}){var n;t=t||{};const e=this.argumentExpressions.map(c=>c.evaluate(t));try{let c=u(t,this.varPath,this.fn);if(c instanceof Function)return c.apply(this,e)}catch(c){}let s;try{s=u((n=this.formulaObject)!=null?n:{},this.varPath,this.fn)}catch(c){}if(this.formulaObject&&s instanceof Function){if(this.isBlacklisted())throw new Error("Blacklisted function called: "+this.fn);return s.apply(this.formulaObject,e)}try{const c=u(Math,this.varPath,this.fn);if(c instanceof Function)return e.forEach(f=>{p.throwIfNotNumber(f)}),c.apply(this,e)}catch(c){}throw new Error("Function not found: "+this.fn)}toString(){return`${this.fn}(${this.argumentExpressions.map(t=>t.toString()).join(", ")})`}isBlacklisted(){return this.blacklisted===void 0&&(this.blacklisted=A.functionBlacklist.includes(this.formulaObject?this.formulaObject[this.fn]:null)),this.blacklisted}}class I extends m{constructor(t,e=null){super();r(this,"fullPath");r(this,"varPath");r(this,"formulaObject");this.formulaObject=e,this.fullPath=t,this.varPath=t.split(".")}evaluate(t={}){var s;let e;try{e=u(t,this.varPath,this.fullPath)}catch(n){}if(e===void 0&&(e=u((s=this.formulaObject)!=null?s:{},this.varPath,this.fullPath)),typeof e=="function")throw new Error(`Cannot use ${this.fullPath} as value: It is a function and not allowed as a variable value.`);return e}toString(){return`${this.varPath.join(".")}`}}var a=(o=>(o.NUMBER="NUMBER",o.VARIABLE="VARIABLE",o.OPERATOR="OPERATOR",o.LOGICAL_OPERATOR="LOGICAL_OPERATOR",o.FUNCTION="FUNCTION",o.LEFT_PAREN="LEFT_PAREN",o.RIGHT_PAREN="RIGHT_PAREN",o.COMMA="COMMA",o.STRING="STRING",o.EOF="EOF",o))(a||{});const l=class l{constructor(){r(this,"input");r(this,"position");this.input="",this.position=0}tokenize(i){this.input=i,this.position=0;const t=[];for(;this.position<this.input.length&&(this.skipWhitespace(),!(this.position>=this.input.length));){const e=this.nextToken(t);e&&t.push(e)}return t.push({type:"EOF",value:"",raw:"",position:this.position,length:0}),t}nextToken(i){return this.readString()||this.readLogicalOperator()||this.readNumber(i)||this.readOperator()||this.readParenthesis()||this.readComma()||this.readIdentifier()||this.throwUnexpectedChar()}skipWhitespace(){const t=this.input.slice(this.position).match(l.PATTERNS.WHITESPACE);t&&(this.position+=t[0].length)}remaining(){return this.input.slice(this.position)}readNumber(i){const t=this.position,s=this.remaining().match(l.PATTERNS.NUMBER);if(!s)return null;const n=s[0];if(n.startsWith("-")){const f=i.length>0?i[i.length-1]:null;if(!(!f||f.type==="OPERATOR"||f.type==="LOGICAL_OPERATOR"||f.type==="COMMA"||f.type==="LEFT_PAREN"))return null}return this.position+=n.length,{type:"NUMBER",value:parseFloat(n),raw:n,position:t,length:n.length}}readIdentifier(){const i=this.position,t=this.remaining();let e=t.match(l.PATTERNS.BRACKETED_IDENTIFIER);if(e){const s=e[0],n=e[1];if(n==="")throw new Error(`Empty bracketed variable at position ${i}`);if(!/^[a-zA-Z0-9_.]+$/.test(n)){const O=n.match(/[^a-zA-Z0-9_.]/),S=O?O[0]:n[0],L=i+1+n.indexOf(S);throw new Error(`Invalid character '${S}' in bracketed variable at position ${L}`)}this.position+=s.length;const c=this.position;this.skipWhitespace();const f=this.position<this.input.length&&this.input[this.position]==="(";return this.position=c,{type:f?"FUNCTION":"VARIABLE",value:n,raw:s,position:i,length:s.length}}if(e=t.match(l.PATTERNS.IDENTIFIER),e){const s=e[0],n=s;this.position+=s.length;const c=this.position;this.skipWhitespace();const f=this.position<this.input.length&&this.input[this.position]==="(";return this.position=c,{type:f?"FUNCTION":"VARIABLE",value:n,raw:s,position:i,length:s.length}}return null}readString(){const i=this.position,t=this.remaining();let e=t.match(l.PATTERNS.STRING_DOUBLE);if(e){const s=e[0],c=e[1].replace(/\\(.)/g,"$1");return this.position+=s.length,{type:"STRING",value:c,raw:s,position:i,length:s.length}}if(e=t.match(l.PATTERNS.STRING_SINGLE),e){const s=e[0],c=e[1].replace(/\\(.)/g,"$1");return this.position+=s.length,{type:"STRING",value:c,raw:s,position:i,length:s.length}}if(t.startsWith('"')||t.startsWith("'"))throw new Error(`Unterminated string at position ${i}`);return null}readOperator(){const i=this.position,e=this.remaining().match(l.PATTERNS.OPERATOR);if(!e)return null;const s=e[0];return this.position+=s.length,{type:"OPERATOR",value:s,raw:s,position:i,length:s.length}}readLogicalOperator(){const i=this.position,t=this.remaining();if(t.startsWith("!")&&!t.startsWith("!="))throw new Error(`Invalid operator '!' at position ${i}. Did you mean '!='?`);const e=t.match(l.PATTERNS.LOGICAL_OPERATOR);if(!e)return null;const s=e[0];return this.position+=s.length,{type:"LOGICAL_OPERATOR",value:s,raw:s,position:i,length:s.length}}readParenthesis(){const i=this.position,t=this.remaining();let e=t.match(l.PATTERNS.LEFT_PAREN);if(e){const s=e[0];return this.position+=s.length,{type:"LEFT_PAREN",value:s,raw:s,position:i,length:s.length}}if(e=t.match(l.PATTERNS.RIGHT_PAREN),e){const s=e[0];return this.position+=s.length,{type:"RIGHT_PAREN",value:s,raw:s,position:i,length:s.length}}return null}readComma(){const i=this.position,e=this.remaining().match(l.PATTERNS.COMMA);if(!e)return null;const s=e[0];return this.position+=s.length,{type:"COMMA",value:s,raw:s,position:i,length:s.length}}throwUnexpectedChar(){const i=this.input[this.position]||"EOF";throw new Error(`Unexpected character '${i}' at position ${this.position}`)}};r(l,"PATTERNS",{WHITESPACE:/^\s+/,NUMBER:/^-?\d+(\.\d+)?/,IDENTIFIER:/^[a-zA-Z_][a-zA-Z0-9_.]*/,BRACKETED_IDENTIFIER:/^\[([^\]]*)\]/,STRING_DOUBLE:/^"((?:[^"\\]|\\.)*)"/,STRING_SINGLE:/^'((?:[^'\\]|\\.)*)'/,LOGICAL_OPERATOR:/^(<=|>=|!=|<|>|=)/,OPERATOR:/^[+\-*/^]/,LEFT_PAREN:/^\(/,RIGHT_PAREN:/^\)/,COMMA:/^,/});let R=l;const b={"=":1,"!=":1,"<":1,">":1,"<=":1,">=":1,"+":2,"-":2,"*":3,"/":3,"^":4};class y{constructor(i,t){r(this,"tokens");r(this,"current");r(this,"formulaObject");this.tokens=i,this.current=0,this.formulaObject=t}parse(){const i=this.parseExpression(0);if(!this.isAtEnd()){const t=this.peek();throw new Error(`Unexpected token '${t.value}' at position ${t.position}: Expected end of expression`)}return i}parseExpression(i){let t=this.parsePrimary();for(;!this.isAtEnd();){const e=this.peek();if(e.type!==a.OPERATOR&&e.type!==a.LOGICAL_OPERATOR)break;const s=this.getPrecedence(e);if(s<i)break;const c=e.value==="^"?s:s+1;this.consume();const f=this.parseExpression(c);t=m.createOperatorExpression(e,t,f)}return t}parsePrimary(){const i=this.peek();if(this.match(a.OPERATOR)&&i.value==="-"){this.consume();const t=this.parsePrimary();return new w("*",new N(-1),t)}if(this.match(a.OPERATOR)&&i.value==="+")return this.consume(),this.parsePrimary();if(this.match(a.NUMBER))return this.consume(),new N(i.value);if(this.match(a.STRING))return this.consume(),new N(i.value,"string");if(this.match(a.LEFT_PAREN))return this.parseParenthesizedExpression();if(this.match(a.VARIABLE,a.FUNCTION))return this.parseVariableOrFunction();throw new Error(`Unexpected token '${i.value}' at position ${i.position}: Expected number, variable, function, or '('`)}parseParenthesizedExpression(){const i=this.consume(a.LEFT_PAREN),t=this.parseExpression(0);if(!this.match(a.RIGHT_PAREN)){const e=this.peek();throw new Error(`Missing closing parenthesis at position ${e.position}: Expected ')' to match '(' at position ${i.position}`)}return this.consume(a.RIGHT_PAREN),new P(t)}parseVariableOrFunction(){const i=this.consume(),t=i.value;return this.match(a.LEFT_PAREN)?this.parseFunctionCall(t,i.position):(this.formulaObject.registerVariable(t),new I(t,this.formulaObject))}parseFunctionCall(i,t){const e=this.consume(a.LEFT_PAREN),s=[];if(!this.match(a.RIGHT_PAREN))do s.push(this.parseExpression(0));while(this.matchAndConsume(a.COMMA));if(!this.match(a.RIGHT_PAREN)){const n=this.peek();throw new Error(`Missing closing parenthesis for function '${i}' at position ${n.position}: Expected ')' to match '(' at position ${e.position}`)}return this.consume(a.RIGHT_PAREN),new x(i,s,this.formulaObject)}peek(){return this.tokens[this.current]}consume(i){const t=this.peek();if(i&&t.type!==i)throw new Error(`Expected ${i} at position ${t.position}, got ${t.type} ('${t.value}')`);return this.current++,t}match(...i){return i.includes(this.peek().type)}matchAndConsume(i){return this.match(i)?(this.consume(),!0):!1}isAtEnd(){return this.peek().type===a.EOF}getPrecedence(i){var t,e;if(i.type===a.LOGICAL_OPERATOR){const s=i.value;return(t=b[s])!=null?t:0}if(i.type===a.OPERATOR){const s=i.value;return(e=b[s])!=null?e:0}return 0}}const v={PI:Math.PI,E:Math.E,LN2:Math.LN2,LN10:Math.LN10,LOG2E:Math.LOG2E,LOG10E:Math.LOG10E,SQRT1_2:Math.SQRT1_2,SQRT2:Math.SQRT2},h=class h{constructor(i,t={}){r(this,"formulaExpression");r(this,"options");r(this,"formulaStr");r(this,"_variables");r(this,"_memory");this.formulaExpression=null,this.options={memoization:!1,...t},this.formulaStr="",this._variables=[],this._memory={},this.setFormula(i)}setFormula(i){return i&&(this.formulaExpression=null,this._variables=[],this._memory={},this.formulaStr=i,this.formulaExpression=this.parse(i)),this}enableMemoization(){this.options.memoization=!0}disableMemoization(){this.options.memoization=!1,this._memory={}}parse(i){const e=new R().tokenize(i);return new y(e,this).parse()}registerVariable(i){this._variables.indexOf(i)<0&&this._variables.push(i)}getVariables(){return this._variables}evaluate(i){if(i instanceof Array)return i.map(e=>this.evaluate(e));let t=this.getExpression();if(!(t instanceof m))throw new Error("No expression set: Did you init the object with a Formula?");if(this.options.memoization){let e=this.resultFromMemory(i);return e!==null||(e=t.evaluate({...v,...i}),this.storeInMemory(i,e)),e}return t.evaluate({...v,...i})}hashValues(i){return JSON.stringify(i)}resultFromMemory(i){let t=this.hashValues(i),e=this._memory[t];return e!==void 0?e:null}storeInMemory(i,t){this._memory[this.hashValues(i)]=t}getExpression(){return this.formulaExpression}getExpressionString(){return this.formulaExpression?this.formulaExpression.toString():""}static calc(i,t=null,e={}){return t=t!=null?t:{},new h(i,e).evaluate(t)}ifElse(i,t,e){return i?t:e}first(...i){for(const t of i)if(t instanceof Array){let e=this.first(...t);if(e)return e}else if(t)return t;if(i.length>0){const t=i[i.length-1];return t instanceof Array?this.first(...t):t}throw new Error("first(): At least one argument is required")}};r(h,"Expression",m),r(h,"BracketExpression",P),r(h,"PowerExpression",T),r(h,"MultDivExpression",w),r(h,"PlusMinusExpression",d),r(h,"LogicalExpression",g),r(h,"ValueExpression",N),r(h,"VariableExpression",I),r(h,"FunctionExpression",x),r(h,"MATH_CONSTANTS",v),r(h,"ALLOWED_FUNCTIONS",["ifElse","first"]),r(h,"Tokenizer",R),r(h,"TokenType",a),r(h,"Parser",y),r(h,"functionBlacklist",Object.getOwnPropertyNames(h.prototype).filter(i=>h.prototype[i]instanceof Function&&!h.ALLOWED_FUNCTIONS.includes(i)).map(i=>h.prototype[i]));let A=h;return A});
//# sourceMappingURL=fparser.umd.cjs.map
